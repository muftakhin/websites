<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Float</title>
    <link rel="stylesheet" href="../../styles/section.css">
</head>
<body class="page">
    <header class="header">
        <h1 class="header__title">Flex</h1>
    </header>
    <article class="article">
        <section class="section">
            <h2 class="section__header">Flex-контейнер</h2>

            <pre class="screen screen_pre">
.container {
    display: flex;
           - inline-flex;

    flex-direction: row;            (default)
                  - row-reverse;
                  - column;
                  - column-reverse;

    flex-wrap: nowrap;              (default)
             - wrap;
             - wrap-reverse;

    flex-flow: flex-direction flex-wrap;


    justify-content: flex-start;    (default)
                   - flex-end;
                   - center;
                   - space-between;
                   - space-around;
                   - space-evenly;

    align-items: flex-start;
               - flex-end;
               - center;
               - baseline;
               - stretch;           (default)

    align-content: flex-start;
                 - flex-end;
                 - center;
                 - space-between;
                 - space-around;
                 - space-evenly;
                 - stretch;
                 - start;
                 - end;
                 - baseline;
                 - first-baseline;
                 - last-baseline;
                 - ...             + safe / unsafe;
}</pre>
            <p class="text">
                <strong>{ justify-content: }</strong> (выравнивание по главной оси) - если элементы располагаются в одну строку<br>
                <strong>{ align-items: }</strong> (выравнивание поперёк главной оси) - если элементы располагаются в одну строку<br>
                <strong>{ align-content: }</strong> (выравнивание поперёк главной оси) - если элементы в располагаются в несколько строк<br>
                <strong>inline-flex</strong> - строчно-блочный контейнер
            </p>
        </section>

        <section class="section">
            <h2 class="section__header">Flex-элемент</h2>

            <pre class="screen screen_pre">
.item {
    order: integer;         (defaulf=0)

    flex-grow: number;      (default=0)

    flex-shrink: number;    (default=1)

    flex-basis: length;
              - auto;       (default)

    align-self: auto;
              - flex-start;
              - flex-end;
              - center;
              - baseline;
              - stretch;
}

.item {
    flex: flex-grow flex_shrink flex_basis;   (default: 0 1 auto)
}
</pre>
            <p class="text">
                &bull; По умолчанию ужимаются под содержимое (если не указаны размеры)<br>
                &bull; Если задать <strong>{order: -1}</strong> элемент переместится в начало, если задать <strong>{order: 1}</strong> - в конец списка. У элементов по умолчанию <strong>{order: 0}</strong><br>
                &bull; <strong>{flex-grow: }</strong> - величина относительно других flex-элементов, до которой может увеличиваться flex-элемент при наличии свободного пространства (относительный размер)<br>
                &bull; <strong>{flex-shrink: }</strong> - величина, до которой может уменьшаться flex-элемент относительно других flex-элементов, когда имеется дефицит пространства (когда размер контейнера меньше суммы размеров элементов). Это значение важно, если у контейнера указан <strong>{ flex-wrap: nowrap; }</strong>. Если при <strong>{ flex-wrap: nowrap; }</strong> <strong>{ flex-shrink: 0 ; }</strong>, то элементы будут расширяться за пределы контейнера<br>
                &bull; Свободное место "съедается" свойствами <strong>{flex-grow: }</strong> или <strong>{margin: auto}</strong> до того, как начнётся применяться выавнивание flex-элементов<br>
                &bull; <strong>{flex-basis: }</strong> - базовый размер, к которому приводится размер flex-элемента. Если <strong>{ flex-grow: 0;}</strong> , то размер элемента будет соответствовать <strong>{ flex-basis: }</strong>(если он указан), а если <strong>{ flex-grow: >0;}</strong> ,то элемент растянется на всю ширину. Разница размера контейнера и суммы <strong>flex-basis</strong> размеров элементов разделится между ними в пропорциях указанных в <strong>flex-hrow</strong> (при условии, что его значение более нуля)<br>
                &bull; <strong>{align-self: }</strong> - переопределение выравнивания для элемента относительно поперечной оси (сделать "не таким как все")<br>
                &bull; При использовании <strong>{display: flex;}</strong> у контейнера, перестаёт работать свойство <strong>{columns}</strong><br>
                &bull; При использовании свойства <strong>{flex: }</strong> у элемента, перестают работать свойства <strong>{float: }</strong>, <strong>{clean: }</strong> и <strong>{vertical-align: }</strong><br>
                &bull; При использовании <strong>{margin: auto;}</strong> элемент центрируется внутри контейнера по вертикали и горизонтали. <strong>margin-...:auto</strong> отъедает всё свободное пространство в этом направлении<br>
                &bull; Если у нескольких элементов <strong>margin-...: auto</strong>, то свободное место делится поровну<br>
                &bull; <strong>{margin: }</strong>ы в <strong>flexbox</strong> не схлопываются, а суммируются<br>
                &bull; Элементы FLEX-контейнера не обязательно должны быть одного типа<br>
                &bull; <strong>::</strong>Псевдоэлементы внутри flex-контейера становятся flex-элементами
            </p>

            <p class="text">
                Чтобы прижать <strong>&lt;footer&gt;</strong> к низу окна, нужно задать <strong>&lt;footer&gt;</strong> и <strong>&lt;header&gt;</strong> <strong>{flex-grow: 0;}</strong>, а <strong>&lt;main&gt;</strong> <strong>{flex-grow: 1;}</strong>
            </p>

            <p class="text">
                Если задать элементу <strong>{ margin-right: auto; }</strong> , то он прижмётся к левой стороне, а справая сторона заполнится пустым пространством (если элементы не заполняют полностью контейнер). Аналогично с другими направлениями
            </p>

            <pre class="screen screen_post">
.container {
    width: 1000px;
    flex-wrap: wrap;
    ...
}
.item {
    flex: 1 1 400px;
}</pre>
            <p class="text">
                3 элемента <strong>.item</strong>. 2 заполнят первую строку, 3-й полностью заполнит вторую строку
            </p>
        </section>

        <section class="section">
            <h2 class="section__header">Рекомендации  построения сеток на FLEX</h2>

            <p class="text">
                &bull; Всегда явно задавайте размер колонок (<strong>width</strong> или <strong>flex-basis</strong>)<br>
                &bull; Расстояние между колонок задавайте с помощью:<br>
                &nbsp; - <strong>justify-content</strong>, если отступы одинаковые<br>
                &nbsp; - <strong>margin</strong>, если отступы разные<br>
                &bull; Если количество колонок может изменяться (карточный интерфейс), то <strong>margin</strong> предпочтительней
                &bull; Чтобы элементы с имеющимися <strong>margin:</strong> прижимались к границам родительского элемента (flex-контейнеру). То этому родительскому <strong>flex-контейеру</strong> задаём отрицательный <strong>margin:</strong>
            </p>
        </section>
    </article>
</body>
</html>