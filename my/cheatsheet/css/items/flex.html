<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Float</title>
    <link rel="stylesheet" href="../../styles/style.css">
</head>

<body class="body">
    <header class="header">
        <a class="header__button"  href="../css.html">&uArr;</a>
        <h1 class="header__title">Flex</h1>
    </header>

    <main class="main">
        <section class="section">
            <h2 class="section__header">Flex-контейнер</h2>

            <pre class="screen screen_pre">
.container {
    display: flex;
           - inline-flex;

    flex-direction: row;            /* default */
                  - row-reverse;
                  - column;
                  - column-reverse;

    flex-wrap: nowrap;              /* default */
             - wrap;
             - wrap-reverse;

    flex-flow: flex-direction flex-wrap;


    justify-content: flex-start;    /* default */
                   - flex-end;
                   - center;
                   - space-between;
                   - space-around;
                   - space-evenly;

    align-items: flex-start;
               - flex-end;
               - center;
               - baseline;
               - stretch;           /* default */

    align-content: flex-start;
                 - flex-end;
                 - center;
                 - space-between;
                 - space-around;
                 - space-evenly;
                 - stretch;
                 - start;
                 - end;
                 - baseline;
                 - first-baseline;
                 - last-baseline;
                 - ...             + safe / unsafe;
}</pre>
            <p class="paragraph">
                <strong>{ justify-content: }</strong> (выравнивание по главной оси) - если элементы располагаются в одну строку<br>
                <strong>{ align-items: }</strong> (выравнивание поперёк главной оси) - если элементы располагаются в одну строку<br>
                <strong>{ align-content: }</strong> (выравнивание поперёк главной оси) - если элементы в располагаются в несколько строк<br>
                <strong>inline-flex</strong> - строчно-блочный контейнер
            </p>
        </section>

        <section class="section">
            <h2 class="section__header">Flex-элемент</h2>

            <pre class="screen screen_pre">
.item {
    order: integer;         /* defaulf=0 */

    flex-grow: number;      /* default=0 */

    flex-shrink: number;    /* default=1 */

    flex-basis: length;
              - auto;       /* default */

    align-self: auto;
              - flex-start;
              - flex-end;
              - center;
              - baseline;
              - stretch;
}

.item {
    flex: flex-grow flex_shrink flex_basis;   /* default: 0 1 auto */
}
</pre>

			<div class="subsection">
				<h3 class="subsection__header">order</h3>
				
				<pre class="screen screen_pre">
order: integer;    /* defaulf=0 */</pre>

				<p class="paragraph">
					<strong>{order: -1}</strong> - в начале списка<br>
                    <strong>{order: 0}</strong> - по умолчанию<br>
                    <strong>{order: 1}</strong> - в конце списка
				</p>
			</div>

			<div class="subsection">
				<h3 class="subsection__header">flex-grow</h3>
				
				<pre class="screen screen_pre">
flex-grow: number;   /* default=0 */</pre>

				<p class="paragraph">- величина относительно других flex-элементов, до которой может увеличиваться flex-элемент при наличии свободного пространства (относительный размер). &quot;Отъедает&quot; в долях(частях) свободное пространство, подобно фракциям <strong>fr</strong></p>
			</div>

            <div class="subsection">
				<h3 class="subsection__header">flex-shrink</h3>
				
				<pre class="screen screen_pre">
flex-shrink: number;   /* default=1 */</pre>

				<p class="paragraph">- величина, до которой может уменьшаться flex-элемент относительно других flex-элементов, когда имеется дефицит пространства (когда размер контейнера меньше суммы размеров элементов). Это значение важно, если у контейнера указан <strong>{ flex-wrap: nowrap; }</strong>. Если при <strong>{ flex-wrap: nowrap; }</strong> <strong>{ flex-shrink: 0 ; }</strong>, то элементы будут расширяться за пределы контейнера</p>
			</div>

            <div class="subsection">
				<h3 class="subsection__header">flex-basis</h3>
				
				<pre class="screen screen_pre">
flex-basis: length;
          - auto;    /* default */</pre>

				<p class="paragraph">
                    - базовый размер, к которому приводится размер flex-элемента<br>
                    &bull; Если <strong>{ flex-grow: 0;}</strong> , то размер элемента будет соответствовать <strong>{ flex-basis: }</strong>(если он указан)<br>
                    &bull; Если <strong>{ flex-grow: >0;}</strong> ,то элемент растянется на всё свободное пространство (&quot;съест его&quot;)<br>
                    &bull; Разница размера контейнера и суммы <strong>flex-basis</strong> размеров элементов разделится между ними в пропорциях указанных в <strong>flex-grow</strong> (при условии, что его значение более нуля)
				</p>
			</div>

            <div class="subsection">
				<h3 class="subsection__header">align-self</h3>
				
				<pre class="screen screen_pre">
align-self: auto;
          - flex-start;
          - flex-end;
          - center;
          - baseline;
          - stretch;</pre>

				<p class="paragraph">- переопределение выравнивания для элемента относительно поперечной оси (сделать "не таким как все")</p>
			</div>

            <p class="paragraph">
                &bull; Свободное место "съедается" свойствами <strong>{flex-grow: }</strong> или <strong>{margin: auto}</strong> до того, как начнётся применяться выавнивание flex-элементов<br>
				&bull; По умолчанию элементы ужимаются под содержимое (если не указаны размеры)<br>
                &bull; При использовании <strong>{display: flex;}</strong> у контейнера, перестаёт работать свойство <strong>{columns}</strong><br>
                &bull; При использовании свойства <strong>{flex: }</strong> у элемента, перестают работать свойства <strong>{float: }</strong>, <strong>{clean: }</strong> и <strong>{vertical-align: }</strong><br>
                &bull; При использовании <strong>{margin: auto;}</strong> элемент центрируется внутри контейнера по вертикали и горизонтали. <strong>{margin-...: auto}</strong> отъедает всё свободное пространство в этом направлении<br>
                &bull; Если у нескольких элементов <strong>{margin-...: auto}</strong>, то свободное место делится поровну<br>
                &bull; <strong>{margin: }</strong>ы в <strong>flexbox</strong> не схлопываются, а суммируются<br>
                &bull; Элементы FLEX-контейнера не обязательно должны быть одного типа<br>
                &bull; <strong>::</strong>Псевдоэлементы внутри flex-контейера становятся flex-элементами
            </p>

            <p class="paragraph">Чтобы прижать <strong>&lt;footer&gt;</strong> к низу окна, нужно задать <strong>&lt;footer&gt;</strong> и <strong>&lt;header&gt;</strong> <strong>{flex-grow: 0;}</strong>, а <strong>&lt;main&gt;</strong> <strong>{flex-grow: 1;}</strong></p>

            <p class="paragraph">Если задать элементу <strong>{ margin-right: auto; }</strong> , то он прижмётся к левой стороне, а справая сторона заполнится пустым пространством (если элементы не заполняют полностью контейнер). Аналогично с другими направлениями</p>

            <pre class="screen screen_post">
.container {
    width: 1000px;
    flex-wrap: wrap;
    ...
}
.item {
    flex: 1 1 400px;
}</pre>
            <p class="paragraph">3 элемента <strong>.item</strong>. 2 заполнят первую строку, 3-й полностью заполнит вторую строку</p>
        </section>

        <section class="section">
            <h2 class="section__header">Рекомендации  построения сеток на FLEX</h2>

            <p class="paragraph">
                &bull; Всегда явно задавайте размер колонок (<strong>width</strong> или <strong>flex-basis</strong>)<br>
                &bull; Расстояние между колонок задавайте с помощью:<br>
                &nbsp; - <strong>justify-content</strong>, если отступы одинаковые<br>
                &nbsp; - <strong>margin</strong>, если отступы разные<br>
                &bull; Если количество колонок может изменяться (карточный интерфейс), то <strong>margin</strong> предпочтительней
                &bull; Чтобы элементы с имеющимися <strong>margin:</strong> прижимались к границам родительского элемента (flex-контейнеру). То этому родительскому <strong>flex-контейеру</strong> задаём отрицательный <strong>margin:</strong>
            </p>

            <p class="paragraph">
                Приоритетность размеров Flex-контейнера:<br>
                1) <strong>flex-basis: (не auto);</strong><br>
                2) <strong>width: (не auto);</strong> при <strong>flex-direction: row;</strong><br>
                &nbsp; или <strong>height: (не auto);</strong> при  <strong>flex-direction: column;</strong><br>
                3) Размер содержимого (по умолчанию)
            </p>
        </section>
    </main>
</body>
</html>