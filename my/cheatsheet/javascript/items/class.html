<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Классы</title>
    <link rel="stylesheet" href="../../styles/style.css">
</head>

<body class="body">
    <header class="header">
        <a class="header__button"  href="../javascript.html">&uArr;</a>
        <h1 class="header__title">Классы</h1>
    </header>

    <main class="main">
        <section class="section">
            <h2 class="section__header">Создание объекта с помощью конструктора</h2>

            <pre class="screen screen_pre">
class Name_1 {
    constructor(name_2){
        this.name_3 = name_2;
    }

    name_4() {
        ... ;
    }
}</pre>
        <p class="paragraph">Метод <strong>name_4</strong> записывается в прототип создаваемого объекта</p>
        <p class="paragraph">Тот же самый класс в функциональном стиле:</p>
        <pre class="screen screen_pre">
function Name_1(name_2) {
    this.name_3 = name_2;
}
    
Name_1.prototype.name_4 = function() {
    ... ;
}</pre>
        </section>

        <section class="section">
            <h2 class="section__header">Создания объекта с помощью статического метода</h3>

            <div class="subsection">
                <h3 class="subsection__header">Статические методы</h3>

                <pre class="screen screen_pre">
class Name_1 {
    constructor(name_2){
        this.name_3 = name_2;
    }
                
    name_4() {
        ... ;
    }

    static name_5() {
        ... ;
    }
}</pre>
                <p class="paragraph"><strong>name_5</strong> - статический метод - метод принадлежащий самому классу, а не создаваемым объектам</p>
            </div>

            <div class="subsection">
                <h3 class="subsection__header">Создания объекта с помощью статичного(фабричного) метода</h3>

                <pre class="screen screen_pre">
class Name_1 {
    constructor(name_2){
        this.name_3 = name_2;
    }
                                    
    name_4() {
        ... ;
    }
                    
    static name_5() {
        return new Name_1();
    }
}</pre>
            </div>
        </section>

        <section class="section">
            <h2 class="section__header">Наследование классов</h2>

            <pre class="screen screen_pre">
class Name_1 {
    constructor(name_2){
        this.name_3 = name_2;
    }

    name_4() {
        action_1;
    }
}

class Name_6 extends Name_1 {
    name_4() {
        action_2;
    }
}</pre>
            <p class="paragraph">
                &bull; Класс <strong>Name_6</strong> наследуется от класса <strong>Name_1</strong><br>
                &bull; Прототипом у объектов создаваемых через класс <strong>Name_6</strong> будет <strong>Name_1</strong><br>
                &bull; Метод <strong>name_4</strong> переопределяется
            </p>

            <pre class="screen screen_pre">
class Name_1 {
    constructor(name_2){
        this.name_3 = name_2;
    }
                
    name_4() {
        action_1;
    }
}
                
class Name_6 extends Name_1 {
    super.name_4();
    name_4() {
        action_2;
    }
}</pre>
            <p class="paragraph">
                &bull; Ключевое слово <strong>super</strong> - это ссылка на прототипа прототипа будущего объекта<br>
                &bull; <strong>super.name_4();</strong> - вызов предыдущей(переопределяемой в данном случае) версии метода прототипа прототипа будущего объекта
            </p>
        </section>
	</main>
</body>