<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Функции</title>
    <link rel="stylesheet" href="../../styles/style.css">
</head>

<body class="body">
    <header class="header">
        <a class="header__button"  href="../javascript.html">&uArr;</a>
        <h1 class="header__title">function</h1>
    </header>

    <main class="main">
        <section class="section">
            <p class="paragraph">
                &bull; Функции позволяют повторно использовать фрагменты кода<br>
                &bull; Параметру функции передаётся аргумент по значению (передаётся копия значения). Параметр инициализируется при передачи аргументом копии его значения<br>
                &bull; При налии функций с одинаковым именем в разных файлах будет использоваться та,которую браузер увидит последней<br>
                &bull; Функцию (ссылку на неё) можно присвоить переменной<br>
                &bull; Функция является значением, и мы можем сохранять её в переменных, массивах, передавать в качестве аргумента других функций или присваивать свойствам объектов
            </p>

            <p class="paragraph">
                &bull; Два способа определения функций:<br>&nbsp;&nbsp; 1. Объявления функций<br>&nbsp;&nbsp; 2. Функциональные выражения<br>
                &bull; Ссылка на функцию - значение, которое может использоваться для обращения к функции<br>
                &bull; Объявления функций обрабатываются до обработки кода<br>
                &bull; Когда браузер обрабатывает объявление функции, он создает функцию и переменную, имя которой совпадает с именем функции, и сохраняет ссылку на функцию в переменной<br>
                &bull; Когда браузер обрабатывает функциональное выражение, он создает функ-цию, а вы сами решаете, что делать со ссылкой<br>
            </p>
        </section>

        <section class="section">
            <h2 class="section__header">Вызов функции</h2>

            <pre class="screen screen_pre">
name_1();</pre>
            <p class="paragraph">
                &bull; Функция вызывается по имени<br>
                &bull; Вызов и передача управления функции это одно и то же
            </p>
        </section>

        <section class="section">
            <h2 class="section__header">Объявление функции</h2>

            <pre class="screen screen_pre">
function name_1(name_2) {
    ...
}</pre>
            <p class="paragraph">- объявление функции с ключевым словом <strong>function</strong>, именем <strong>name_1</strong>, параметром <strong>name_2</strong> и блоком кода <strong>{ ... }</strong></p>

            <p class="paragraph">
                &bull; Имя функции <strong>name_1</strong> фактически является переменной, содержащий код функции<br>
                &bull; Функция объявляется с использованием ключевого слова <strong>function</strong><br>
                &bull; Параметры заключаются внутри круглых скобок. Если параметров нет, используются пустые скобки<br>
                &bull; Тело функции (блок кода) находится внутри фигурных скобок, которое содержит команды (операторы)<br>
                &bull; Функция создаёт локальную область действия параметров и локальных переменных используемых ею
            </p>
        </section>
                
        <section class="section">
            <h2 class="section__header">Функциональное выражение</h2>

            <pre class="screen screen_pre">
let name_3 = function(name_4) {
    ...
};</pre>
            <p class="paragraph">
                &bull; Функция вызывается через переменную <strong>name_3</strong><br>
                &bull; В отличии от объявления, эта функция не имеет имени<br>
                &bull; Результатом обработки функционального выражения является значение, которое затем присваивается переменной <strong>name_3</strong>. Это значение является ссылкой на функцию<br>
                &bull; Можно передать другой функции или вернуть его из функции
            </p>

            <p class="paragraph">
                &bull; Сначала браузер ищет объявления функций<br>
                &bull; Затем он обрабатывает функцию и создаёт переменную с именем функции, в которой хранит ссылку на эту функцию, для дальнейшего использования<br>
                &bull; После обработки всех объявлений функций браузер переходит в начало кода и начинает его выполнять от начала к концу
            </p>

            <p class="paragraph">
                Отличие объявления функции от функционального выражения:<br>
                &bull; С объявлением, функция создаётся и подготавливается до обработки остального кода. А с функциональным выражением, функция создаётся при выполнении кода (на стадии выполнения)<br>
                &bull; С объявлением, имя функции используется для создания переменной, содержащей ссылку на функцию. А при использовании функционального выражениея имя функции не указывается, а функция либо присваивается переменной в коде, либо используется иным образом<br>
            </p>
        </section>

        <section class="section">
            <h2 class="section__header">Анонимные функции</h2>

            <p class="paragraph">- функциональное выражение без имени</p>
            <p class="paragraph">
                &bull; При определении функции с использованием функционального выражения присваивать функции имя не обязательно<br>
                &bull; Вместо переменной с сылкой на функцию мы подставляем функциональное выражение (которое при расчёте становится ссылкой)
            </p>
            <pre class="screen screen_pre">
... = function() {
    ...
};</pre>
        </section>

        <section class="section">
            <h2 class="section__header">Вложенные функции</h2>

            <p class="paragraph">- определяются внутри других функций</p>

            <p class="paragraph">Вложенная функция имеет локальную область видимости, как и другие переменные</p>

            <p class="paragraph">Внутри функции при определении вложенной функции посредством объявления эта вложенная функция определена в любой точке тела функции. С другой стороны, если при создании вложенной функции используется функциональное выражение, то эта вложенная функция определена только после обработки функционального выражения</p>
            <pre class="screen screen_pre">
let name_1 = function() {
    ...

    function name_2() {
        ...
    }
};

function name_3 {
    ...

    let name_4 = function () {
    ...
    };
}</pre>
        </section>

        <section class="section">
            <h2 class="section__header">Функции как значения</h2>

            <p class="paragraph">Функции в JavaScript являются значениями - значениями, которые могут присваиваться переменным</p>
            <pre class="screen screen_pre">
function name_1(name_2) {
    ...
}

let name_3 = function(name_4) {
    ...
};

let name_5 = name_1;
let name_6 = name_3;

name_5(value_1);
name_6(value_2);</pre>
            <p class="paragraph">
                &bull; Ссылка на функции содержащиеся в переменных <strong>name_1</strong> и <strong>name_3</strong> присваиваются переменным <strong>name_5</strong> и <strong>name_6</strong> соответственно<br>
                &bull; Эти функции могут быть вызваны используя имена переменных <strong>name_5</strong> и <strong>name_6</strong> с круглыми скобками и атрибутами в них, если они есть
            </p>
        </section>

        <section class="section">
            <h2 class="section__header">Передача аргументов в функцию</h2>

            <p class="paragraph">
                &bull; При вызове функции ей передаются аргументы, которые сопоставляются с параметрами из определения функции. В аргументе можно передать практически любое значение. Переменные тоже могут передаваться как аргументы
                &bull; Параметры определяются один раз при определении функции (являются локальными переменными функции)<br>
                &bull; Аргументы передаются функции каждый раз при её вызове (значение аргумента копируется в параметр, или значение переменной копируется в параметр, являющийся переменной функции)
            </p>

            <pre class="screen screen_post">
function name_1(name_2, name_3, ..., name_n) {
    ...
}

let name_4 = function(name_5, name_6, ..., name_n) {
    ...
};</pre>

            <p class="paragraph"> 
                &bull; Параметрам не получившим аргумент присваивается значение <strong>undefined</strong><br>
                &bull; Если переданы лишние аргументы, то они игнорируются
            </p>
        </section>

        <section class="section">
            <h2 class="section__header">Возврат значения из функции</h2>

            <p class="paragraph">
                &bull; Чтобы вернуть из функции значение, используется оператор <strong>return</strong>, после которого  указывается само значение<br>
                &bull; После <strong>return</strong> все строки кода внутри функции игнорируются
                &bull; Оператор <strong>return</strong> включает выражение, которое возвращается в качестве результата вызова функции
            </p>

            <pre class="screen screen_pre">
function name_1(parameter) {
    ...         ;
    return x + y;
}

let name_2 = name_1(parameter);
alert(name_2);</pre>
            <p class="paragraph">Функция <strong>name_1</strong> возвращает значение переменной <strong>name_2</strong></p>

            <pre class="screen screen_post">
let double = function(number) {
    return number * 2;
};
   
double(3); вернёт 6</pre>
            <p class="paragraph">Если не указать в теле функции, что именно возвращать, она вернёт <strong>undefined</strong></p>

            <p class="paragraph">Также вызов функции можно указать в качестве аргумента другой функции</p>
            <pre class="screen screen_post">
double(double(3));</pre>

            <div class="subsection">
                <h3 class="subsection__header">Ранний выход из функции по return</h3>

                <p class="paragraph">
                    &bull; Когда JavaScript, выполняя код функции, встречает оператор <strong>return</strong>, он завершает выполнение функции, даже если после остался код<br>
                    &bull; <strong>return</strong> часто используют для выхода из функции в самом начале, если какие-нибудь из переданных аргументов имеют некорректные значения - т.е. если с такими аргументами функция не сможет правильно работать
                </p>
            </div>

            <div class="subsection">
                <h3 class="subsection__header">Многократное использование return вместо конструкций if ... else</h3>

                <pre class="screen screen_post">
let medalForScore = function (score) {
    if (score &lt; 3) {
        return "Bronze";
    }

    if (score &lt; 2) {
        return "Silver";
    }

    return "Gold";
};</pre>
            </div>
        </section>

        <section class="section">
            <h2 class="section__header">Лексическая область действия</h2>

            <div class="subsection">
                <h3 class="subsection__header">Замыкание</h3>

                <p class="paragraph">- функция вместе с её окружением (свободными переменными), внутри лексической области действия (в теле функции, в которую они вложены)</p>

                <div class="subsubsection">
                    <h4 class="subsubsection__header">Свободные переменные</h4>

                    <p class="paragraph">- переменные используемые в теле вложенной функции и объявляемые за пределами этой вложенной функции, но при этом не являющиеся глобальными и находящиеся вместе с этой вложенной функцией внутри окружения лексической области действия в которой эта вложенная функция замкнута, и в этой же области содержатся значения этих переменных</p>
                    <p class="paragraph">
                        &bull; При выполнении замыкания в контексте, отличном от контекста его создания, значения свободных переменных определяются окружением<br>
                        &bull; Замыкания часто используются для сохра-нения состояния в обработчиках событий
                </div>

                <div class="subsubsection">
                    <h4 class="subsubsection__header">Замыкание при помощи возвращения функции</h5>

                    <pre class="screen screen_pre">
let name_1 = x_1;
let name_2 = y_1;

function name_3() {
    let name_1 = x_2;
    let name_2 = y_2;

    return function () {
        return name_1 + name_2;
    }
}

let name_4 = name_3;

name_4(); // >> x_2 + y_2</pre>

                    <pre class="screen screen_post">
Счётчик с замыканием:

function name_1() {
    let name_2 = 0;

    function name_3() {
        name_2 = name_2 + 1;
        return name_2;         
    }

    return name_3;
}

let name_4 = name_1;</pre>
                    <p class="paragraph">- счётчик с локальной и защищённой переменной <strong>name_2</strong>, которая не будет конфликтовать с другими переменными, а увеличить её можно только вызовом функции. Т.е. доступна она только через функцию</p>

                    <pre class="screen screen_post">
function name_1(name_2) {
    return function(name_3) {
        return name_3 + name_2;
    }
}

const name_4 = name_1(name_2);

console.log(name_4(name_3));</pre>
                </div>

                <p class="paragraph">Замыкания создаются везде, где появляется ссылка на функцию со свободными переменными, и эта функция выполняется вне контекста, в котором она была создана</p>

                <div class="subsubsection">
                    <h4 class="subsubsection__header">Замыкание создаваемые передачей функции при вызове функции </h5>

                    <p class="paragraph">Передаваемая функция выполняется в контексте, отличном от контекста её создания</p>

                    <pre class="screen screen_post">
function name_1(string_1, x_1) {
    setTimeout( function() {
        alert(string_1);
    }, x_1);
}
                
name_1(string_1, x_1);</div>
                <p class="paragraph">
                    &bull; <strong>name_1</strong> - функциональное выражение содержащее свободную переменную <strong>string_1</strong>, передаётся параментру функции <strong>setTimeout</strong> в качестве значения аргумента
                    &bull; При этом функциональное выражение обрабатывается для получения ссылки на функцию, которая затем передается <strong>setTimeout</strong><br>
                    &bull; Метод <strong>setTimeout</strong> сохраняет функцию (а вернее, функцию вместе с окружением — иначе говоря, замыкание), после чего через <strong>x_1</strong> миллисекунд вызывает ее
                    &bull; Функция, передаваемая <strong>setTimeout</strong>, представляет собой замыкание, потому что вместе с ней передается окружение, связывающее свободную переменную <strong>string_1</strong> с значением передаваемым ей атрибутом
                </p>
            </div>
        </section>

        <section class="section">
            <h2 class="section__header">Упрощение кода с помощью функций</h2>

            <div class="subsection">
                <h3 class="subsection__header">Функции для выбора случайного элемента массива слова</h3>

                <pre class="screen screen_pre">
let name_1 = ["One", "Two", "...", "N"];
let name_2 = function(name_3) {
    return name_3[Math.floor(Math.random() * name_3.length)];
};</pre>
           
                <p class="paragraph">С помощью функции <strong>name_2</strong> можно получить случайный элемент из массива <strong>name_1</strong>, передав его с помощью аргумента, параметру <strong>name_3</strong></p>
                <pre class="screen screen_pre">
name_2(name_1);</pre>
            </div>
        </section>

        <section class="section">
            <h2 class="section__header">Самовызывающаяся функция</h2>

            <pre class="screen screen_pre">
(function () {...}())</pre>
        </section>

        <section class="section">
            <h2 class="section__header">Стрелочные функции</h2>

            <pre class="screen screen_pre">
    Традиционная:

var name_1 = function(name_2) {
    return action_1;
}

    Стрелочная:

var name_1 = name_2 => action_1</pre>

            <p class="paragraph">
                &bull;Стрелка <strong>=></strong> указывает на то, что должно быть возвращено, поэтому в данном примере можно не использовать <strong>return</strong><br>
                &bull;Если функция принимает только один аргумент (в данном примере это <strong>name_2</strong>), то можно убрать скобки обосабливающие аргументы
            </p>

            <pre class="screen screen_pre">
    Традиционная:
            
var name_1 = function(name_2, name_3) {
    return action_1;
}
            
    Стрелочная:
            
var name_1 = (name_2, name_3) => action_1</pre>

            <p class="paragraph">
                Если тело функции состоит из нескольких строк, то его следует заключить в фигурные скобки
            </p>
            <p class="paragraph">
                Стрелочные функции не изолируют область видимости ключевого слова <strong>this</strong>
            </p>
        </section>
    </main>
</body>
</html>