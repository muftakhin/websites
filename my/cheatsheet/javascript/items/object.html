<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Объекты</title>
    <link rel="stylesheet" href="../../styles/style.css">
</head>

<body class="body">
    <header class="header">
        <a class="header__button"  href="../javascript.html">&uArr;</a>
        <h1 class="header__title">object</h1>
    </header>

    <main class="main">
        <section class="section">
            <p class="paragraph">
                &bull; Объект представляет собой всего лишь коллекцию(набор) свойств, которые представляют собой пары {ключ(имя свойства): значение}<br>
                &bull; Для доступа к элементам объекта (свойствам и их значениям) используются ключи, а не числа (индексы) как в массиве<br>
                &bull; Объект обладает состоянием и поведением
            </p>
        </section>

        <section class="section">
            <h2 class="section__header">Готовые объекты JavaScript</h2>

                <div class="table">
                    <div class="table__header">Предоставляет JavaScript</div>

                    <div class="table__screen">Date</div>
                    <div class="table__definition">Для работы с датой и временем</div>

                    <div class="table__screen">Math</div>
                    <div class="table__definition"></div>

                    <div class="table__screen">RegExp</div>
                    <div class="table__definition">Позволяет искать текст в строках по заданному шаблону</div>

                    <div class="table__screen">JSON</div>
                    <div class="table__definition">С помощью него можно передавать объекты <strong>objects</strong> в другие</div>
                </div>

                <div class="table">
                    <div class="table__header">Предоставляет Браузер</div>

                    <div class="table__screen">Document</div>
                    <div class="table__definition">Для записи в страницу из программного кода</div>

                    <div class="table__screen">Window</div>
                    <div class="table__definition">Предоставляет свойства, относящиеся к браузеру и методы, используемые в коде</div>

                    <div class="table__screen">Console</div>
                    <div class="table__definition">Его метод <strong>.log</strong> используется для вывода в консоль сообщений, <strong>clear</strong> - для очистки, <strong>table</strong> - для вывода объектов в виде таблицы</div>
                </div>
            </div>
        </section>

        <section class="section">
            <h2 class="section__header">Создание объектов</h2>

            <div class="subsection">
                <h3 class="subsection__header">С использованием объектных литералов</h3>

                <p class="paragraph">
                    &bull; Объектный литерал - полное описание объекта
                    &bull; Подходит для создания небольшого количества объектов
                </p>
                <pre class="screen screen_pre">
let name_1 = {
    "string_1": value_1,
    "string_2": value_2,
        ...
    "string_n": value_n       
};</pre>
                <p class="paragraph">
                    &bull; Определение объекта начинается с символа <strong>{</strong><br>
                    &bull; Ключ всегда строковый и его можно записывать без кавычек, но по_правилам<br>
                    &bull; Фигурные скобки и их содержимое называется литералом объекта<br>
                    &bull; В переменной хранится не сам объект, а ссылка на объект (значение представляющее механизм обращения к конкретному объекту). Такая переменная называется ссылочная переменная
                </p>
            </div>

            <div class="subsection">
                <h3 class="subsection__header">Создание пустого объекта</h3>

                <pre class="screen screen_pre">
let name_1 = {};</pre>
            </div>
        </section>

        <section class="section">
            <h2 class="section__header">Доступ к значениям внутри объектов</h2>

            <pre class="screen screen_pre">
name_1["name_2"]; - скобочная нотация

name_1.name_2;    - точечная нотация

где:    name_1 - имя объекта
        name_2 - ключ(свойство, строка) объекта</pre>
            <p class="paragraph">
                &bull; Отличие от массива - вместо индекса(числа) ключ(строка)<br>
                &bull; Точечная нотация возможна, если имя ключа соответствует правилам
            </p>
                
            <pre class="screen screen_pre">
name_1.keys(); - возвращает массив, содержащий все ключи объекта name_1</pre>

            <p class="paragraph">При обращении к несуществующему свойству объекта, вернётся <strong>undefined</strong></p>

            <p class="paragraph">
                &bull; Скобочная нотация позволяет заключать в квадратные скобки любые выражения. Необходимо лишь, чтобы результатом его вычисления являлось имя свойства<br>
                &bull; Скобочная нотация позволяет записывать вместо имени свойства переменную<br>
                &bull; Скобочная нотация позволяет записать в качестве имени свойства строку из нескольих слов
            </p>
            <pre class="screen screen_pre">
name_1['one' + 'two'];
                    
    равно
                    
name_1.['onetwo'];</pre>
        </section>

        <section class="section">
            <h2 class="section__header">Добавление свойств объекту</h2>

            <pre class="screen screen_pre">
name_1["name_3"] = value_1;</pre>
                
            <pre class="screen screen_pre">
let name_1 = {};
name_1["name_2"] = value_1;
name_1["name_3"] = value_2;
...
name_1["name_n"] = value_n;</pre>

            <div class="subsection">
                <h3 class="subsection__header">Используя точечную нотацию</h3>

                <pre class="screen screen_pre">
name_1.name_3 = value_1;</pre>

                <pre class="screen screen_pre">
let name_1 = {};
name_1.name_2 = value_1;
name_1.name_3 = value_2;
...
name_1.name_n = value_n;</pre>
            </div>
        </section>

        <section class="section">
            <h2 class="section__header">Удаление элемента объекта (свойства)</h2>

            <pre class="screen screen_pre">
delete name_1.name_2;</pre>

            <p class="paragraph">- выраженние <strong>delete</strong> возвращает <strong>true</strong> если свойство было успешно удалено (либо если вы удаляете не существующее свойство или то, что не является свойством объекта</p>
        </section>

        <section class="section">
            <h2 class="section__header">Вычисления с использованием свойств объекта</h2>

            <p class="paragraph">Свойство объекта можно использовать так же как переменную:</p>
            <pre class="screen screen_post">
if (car.whells &lt; 4) {
    ready = true;
}

for (let i = 0; i &lt; 3; car.passengers++) {
    addPassenger();
}</pre>
        </section>

        <section class="section">            
            <h2 class="section__header">Перечислние свойств объекта</h2>

            <p class="paragraph">Для перечисления свойств объекта <strong>name_2</strong> используем цикл <strong>for-in</strong>:</p>
            <pre class="screen screen_pre">
let name_1;
for (name_1 in name_2) {
    alert (name_1);
}</pre>
            <p class="paragraph">
                При каждом выполнении цикла переменная <strong>name_1</strong> получает строковое значение следующего по очереди имени свойства объекта <strong>name_2</strong>
            </p>
            <pre class="screen screen_pre">
name_2[name_1];</pre>
            <p class="paragraph">Используя скобочную нотацию можем получить доступ к значению соответствующего свойства <strong>name_1</strong> объекта <strong>name_2</strong></p>

            <p class="paragraph">Для перечисления свойств и их значений:</p>
            <pre class="screen screen_pre">
for (let name_1 in name_2) {
    console.log (name_1 + ': ' + name_2[name_1]);
}</pre>
        </section>

        <section class="section">
            <h2 class="section__header">Массив объектов</h2>

            <pre class="screen screen_pre">
let name_1 = [
    { name_2: value_1, name_3: value_2 },
    { name_4: value_3, name_5: value_4 },
    { name_6: value_5, name_7: value_6 }
];
           
name_1[0]; - вернёт { name_2: value_1, name_3: value_2 }
name_1[1][name_4]; - вернёт value_3

name_1[2].name_7; - вернёт value_6</pre>

            <pre class="screen screen_pre">
    Создадим 3 объекта:            

let name_1 = { name_2: value_1, name_3: value_2, name_4: [value_3, value_4, value_5, value_6] };
let name_5 = { name_6: value_7, name_7: value_8, name_8: [value_9, value_10, value_11] };
let name_9 = { name_10: value_12, name_11: value_13, name_12: [value_14, value_15, value_16] };
           
    Создадим массив из объектов:
           
let name_17 = [name_1, name_5, name_9];</pre>

            <div class="subsection">
                <h3 class="subsection__header">Получение объектов из массива</h3>

                <pre class="screen screen_pre">
name_17[1]; - вернёт - { name_6: value_7, name_7: value_8, name_8: [value_9, value_10, value_11] }

name_17[2].name_11; - вернёт - value_13
           
name_17[0].name_4[1]; - вернёт - value_4</pre>
            </div>
        </section>

        <section class="section">
            <h2 class="section__header">Передача объектов функциям</h2>

            <p class="paragraph">
                &bull; При присвоении объекта переменной, переменная будет содержать не сам объект, а ссылку (указатель) на объект. Если передать параметру функции в качестве аргумента значение этой переменной , то в переменной параметра функции будет храниться копия ссылки на объект<br>
                &bull; При изменении свойства объекта внутри функции, изменяется свойство исходного объекта (функция "портит" объект)
            </p>
            <pre class="screen screen_post">
pluto.weight = 48;

function loseWeight(dog) {
    dog.weight = dog.weight - 2;
}

loseWeight(pluto)

alert(pluto.name + " now weights " + pluto.weight);</pre>
        </section>

        <section class="section">
            <h2 class="section__header">Методы</h2>

            <p class="paragraph">
                &bull; Помимо строк, чисел и булевых значений в свойствах объектов можно хранить <strong>функции</strong> (функция является значением свойства) - тогда эти свойства называются <strong>методами</strong><br>
                &bull; Методы могут получать аргументы
            </p>
                
            <pre class="screen screen_pre">
let name_1 = {
    name_2 : value_1,
    name_3 : value_2,
    name_4 : function() {
            ...
    }
};</pre>
            <p class="paragraph">те же яйца, только в профиль:</p>
            <pre class="screen screen_pre">
let name_1 = {
    this.name_2 = value_1,
    this.name_3 = value_2,
    this.name_4 = function() {
            ...
    }
};</pre>
            <p class="paragraph"><strong>name_4</strong> - метод объекта <strong>name_1</strong></p>
                
            <pre class="screen screen_pre">
name_1.name_4(); - вызов метода</pre>

            <p class="paragraph">
                Разница между функцией и методом:<br>
                &bull; Функция - отдельный блок кода, который можно вызвать<br>
                &bull; Метод - поведение привязанное к определённому объекту
            </p>

            <pre class="screen screen_pre">
let name_1 = {
    name_2 : value_1,
    name_3 ( name_4 ){
        action_1;
    }
};</pre>

            <div class="subsection">
                <h3 class="subsection__header">Добавление объектам новых методов</h3>
                    
                <pre class="screen screen_pre">
name_1.name_5 = function() {
            ...
};</pre>
                <p class="paragraph">- добавили объекту <strong>name_1</strong> свойство <strong>name_5</strong> и задали в качестве его значения функцию (т.е. добавили объекту <strong>name_1</strong> метод <strong>name_5</strong> )</p>
            </div>

            <div class="subsection">
                <h3 class="subsection__header">Ключевое слово this</h3>

                <p class="paragraph">
                    &bull; - не является переменной<br>
                    &bull; Ключевое слово <strong>this</strong> можно использовать в теле метода, чтобы обратиться к объекту (интерпритируется как ссылка на объект), для которого этот метод вызывается<br>
                    &bull; Делает методы более гибкими, позволяя добавлять один и тот же метод ко многим объектам так, чтобы он имел доступ к свойствам того объекта, для которого в данный момент вызывается
                </p>
            </div>

            <div class="subsection">                
                <h3 class="subsection__header">Использование одного метода с разными объектами</h3>

                <p class="paragraph">Создадим функцию <strong>name_1</strong>, чтобы затем использовать её как метод с разными объектами</p>
                <pre class="screen screen_pre">
let name_1 = function() {
        ...
};</pre>
                <p class="paragraph">Теперь создадим объект <strong>name_2</strong>, и добавим в него 2 свойства и метод <strong>name_1</strong></p>
                <pre class="screen screen_pre">
let name_2 = {
    name_3: value_1,
    name_4: value_2,
    name_5: name_1
};</pre>
                <p class="paragraph">
                    &bull; Создали объект <strong>name_2</strong> со свойствами <strong>name_3</strong>, <strong>name_4</strong> и <strong>name_5</strong><br>
                    &bull; Присвоили свойству <strong>name_5</strong> значение - функцию <strong>name_1</strong><br>
                    &bull; Теперь <strong>name_2.name_1</strong> является методом, который можно вызвать командой <strong>name_2.name_1()</strong>
                </p>

                <p class="paragraph">Функцию <strong>name_1</strong> можно использовать как метод и для других объектов:</p>
                <pre class="screen screen_pre">
let name_6 = {
    name_7: value_3,
    name_8: value_4,
    name_9: name_1
};

let name_10 = {
    name_11: value_5,
    name_12: value_6,
    name_13: name_1
};</pre>
                <p class="paragraph">Чтобы использовать один и тот же код метода с разными объектами, достаточно добавить его в виде свойства каждому из этих объектов</p>
            </div>
        </section>

        <section class="section">
            <h2 class="section__header">Деструктурирующее присваивание</h2>

            <div class="subsection">
                <h3 class="subsection__header">Деструктуризация из объекта</h3>

                <pre class="screen screen_pre">
var name_1 = {
    name_2: value_1,
    name_3: value_2,
    name_4: value_3,
    name_5: ["", "", ""]
}

var {name_2, name_3} = name_1;</pre>
                <p class="paragraph">
                    &bull;<strong>name_2</strong> и <strong>name_3</strong> вытаскиваются из объекта <strong>name_1</strong> и для них создаются переменные с соответствующим именем и значением<br>
                    &bull;Значения созданных в процессе деструктуризации переменных могут быть изменены
                </p>
                <pre class="screen screen_pre">
name_2 = value_4;
name_3 = value_5;</pre>
            </div>

            <div class="subsection">
                <h3 class="subsection__header">Деструктуризация из массива</h3>

                <pre class="screen screen_pre">
var [name_1] = ["value_1", "value_2", ..., "value_n"];
var [,name_2] = ["value_1", "value_2", ..., "value_n"];
...
var [,,,name_3] = ["value_1", "value_2", ..., "value_n"];</pre>

                <p class="paragraph">
                    &bull; Переменной <strong>name_1</strong> будет присвоено первое значение массива, <strong>name_1</strong> - второе, а <strong>name_3</strong> - четвёртое<br>
                    &bull; Запятых перед именем переменной, которой присваивается <strong>n-ое</strong> значение массива, должно быть в количестве равном <strong>n-1</strong> (соответствующему количеству пропущенных элементов)
                </p>
            </div>
        </section>

        <section class="section">
            <h2 class="section__header">Расширение объектных литералов (реструктурирование)</h2>

            <pre class="screen screen_pre">
var name_1 = value_1;
var name_2 = value_2;
var name_3 = function() {
    action_1;
};

var name_4 = {name_1,name_2,name_3};</pre>
            <p class="paragraph"><strong>name_1</strong> и <strong>name_2</strong> становятся свойствами, а <strong>name_3</strong> методом объекта <strong>name_4</strong>:</p>
            <pre class="screen screen_pre">
var name_4 = {
    name_1: value_1,
    name_2: value_2
    name_3: function() {
        action_1;
    }
};</pre>
    </main>
</body>
</html>