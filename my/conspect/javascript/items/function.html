<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Функции</title>
  <link rel="stylesheet" href="../../styles/style.css">
</head>

<body class="body">
  <header class="header">
    <a class="header__button"  href="../javascript.html">&uArr;</a>
    <h1 class="header__title">function</h1>
  </header>

  <main class="main">
    <section class="section">
      <p class="p">
        &bull; Функции позволяют повторно использовать фрагменты кода.<br>
        &bull; Параметру функции передаётся аргумент по значению (передаётся копия значения). Параметр инициализируется при передачи аргументом копии его значения.<br>
        &bull; При налии функций с одинаковым именем в разных файлах будет использоваться та,которую браузер увидит последней.<br>
        &bull; Функцию (ссылку на неё) можно присвоить переменной.<br>
        &bull; Функция является значением, и мы можем сохранять её в переменных, массивах, передавать в качестве аргумента других функций или присваивать свойствам объектов.
      </p>

      <p class="p">
        &bull; Два способа определения функций:<br>
        &nbsp;&nbsp; 1. Объявления функций.<br>
        &nbsp;&nbsp; 2. Функциональные выражения.<br>
        &bull; Ссылка на функцию - значение, которое может использоваться для обращения к функции.<br>
        &bull; Объявления функций обрабатываются до обработки кода.<br>
        &bull; Когда браузер обрабатывает объявление функции, он создает функцию и переменную, имя которой совпадает с именем функции, и сохраняет ссылку на функцию в переменной.<br>
        &bull; Когда браузер обрабатывает функциональное выражение, он создает функцию, а вы сами решаете, что делать со ссылкой.<br>
        &bull; Вызвать функцию созданной через объявление можно в любом месте кода, а созданную функциональным выражением, в коде ниже.
      </p>

      <p class="p">
        &bull; Чистая функция - это функция, которая возвращает значение, вычисляемое на основе её аргументов.<br>
        &bull; Чистые функции получают как минимум один аргумент и всегда возвращают значение или другую функцию.<br>
        &bull; Эти функции не имеют побочных эффектов, не устанавливают значений глобальных переменных и не изменяют ничего, что относится к состоянию приложения.<br>
        &bull; Они рассматривают свои аргументы в качестве неизменяемых данных.
      </p>

      <p class="p">
        При написании функции следуйте правилам:<br>
        &nbsp; 1. Функция должна получать как минимум один аргумент.<br>
        &nbsp; 2. Функция должна возвращать значение или другую функцию.<br>
        &nbsp; 3. Функция не должна вносить какие-либо изменения в переданные ей аргументы.
      </p>
    </section>

    <section class="section">
      <h2 class="section__header">Объявление и вызов функции</h2>

      <p class="p">
        <strong>function declaration</strong> - создаётся и подготавливается до обработки остального кода(скрипта) и может быть вызвана до объявления.
      </p>
      <pre class="screen screen_pre">
function name_1(parameter_1) {
    action_1;
}</pre>
      <pre class="screen screen_pre">
name_1();</pre>
      <p class="p">
        - объявление функции с ключевым словом <strong>function</strong>, именем <strong>name_1</strong>, параметром <strong>parameter_1</strong> и блоком кода <strong>{ ... }</strong>
      </p>

      <p class="p">
        &bull; Имя функции <strong>name_1</strong> фактически является переменной, содержащий код функции.<br>
        &bull; Функция объявляется с использованием ключевого слова <strong>function</strong>.<br>
        &bull; Параметры заключаются внутри круглых скобок. Если параметров нет, используются пустые скобки.<br>
        &bull; Тело функции (блок кода) находится внутри фигурных скобок, которое содержит команды (операторы).<br>
        &bull; Функция создаёт локальную область действия параметров и локальных переменных используемых ею.
      </p>

      <p class="p">
        &bull; Функция вызывается по имени.<br>
        &bull; Вызов и передача управления функции это одно и то же.
      </p>
    </section>

    <section class="section">
      <h2 class="section__header">Функциональное выражение</h2>

      <p class="p">
        <strong>function expression</strong> - создаётся и вызывается в порядке очереди.
      </p>
      <pre class="screen screen_pre">
let name_1 = function(parameter_1) {
    action_1;
};</pre>
      <p class="p">
        &bull; Функция вызывается через переменную <strong>name_1</strong>.<br>
        &bull; В отличии от объявления, эта функция не имеет имени.<br>
        &bull; Результатом обработки функционального выражения является значение, которое затем присваивается переменной <strong>name_1</strong>. Это значение является ссылкой на функцию.<br>
        &bull; Можно передать другой функции или вернуть его из функции.
      </p>

      <p class="p">
        &bull; Сначала браузер ищет объявления функций.<br>
        &bull; Затем он обрабатывает функцию и создаёт переменную с именем функции, в которой хранит ссылку на эту функцию, для дальнейшего использования.<br>
        &bull; После обработки всех объявлений функций браузер переходит в начало кода и начинает его выполнять от начала к концу.
      </p>

      <p class="p">
        Отличие объявления функции от функционального выражения:<br>
        &bull; С объявлением, функция создаётся и подготавливается до обработки остального кода. А с функциональным выражением, функция создаётся при выполнении кода (на стадии выполнения)/<br>
        &bull; С объявлением, имя функции используется для создания переменной, содержащей ссылку на функцию. А при использовании функционального выражениея имя функции не указывается, а функция либо присваивается переменной в коде, либо используется иным образом.<br>
      </p>
    </section>

    <section class="section">
      <h2 class="section__header">Анонимные функции</h2>

      <p class="p">
        - функциональное выражение без имени
      </p>
      <p class="p">
        &bull; При определении функции с использованием функционального выражения присваивать функции имя не обязательно.<br>
        &bull; Вместо переменной с сылкой на функцию мы подставляем функциональное выражение (которое при расчёте становится ссылкой).
      </p>
      <pre class="screen screen_pre">
let name_1 = function() {
  expression_1;
};</pre>
    </section>

    <section class="section">
      <h2 class="section__header">Вложенные функции</h2>

      <p class="p">
        - определяются внутри других функций.
      </p>

      <p class="p">
        Вложенная функция имеет локальную область видимости, как и другие переменные.
      </p>

      <p class="p">
        Внутри функции при определении вложенной функции посредством объявления эта вложенная функция определена в любой точке тела функции. С другой стороны, если при создании вложенной функции используется функциональное выражение, то эта вложенная функция определена только после обработки функционального выражения.
      </p>
      <pre class="screen screen_pre">
let name_1 = function() {
  expression_1;

  function name_2() {         // Определена в любой точке тела функции.
    expression_2;
  }
};

function name_3() {
  expression_3;

  let name_4 = function() {   // Определена только после обработки функционального
    expression_4;             // выражения, ниже по коду.
  };
}</pre>
    </section>

    <section class="section">
      <h2 class="section__header">Callback</h2>

      <p class="p">
        Callback - это функция, которая должна быть выполнена после того, как другая функция завершит работу.<br>
        Передаётся в качестве аргумента другой функции.
      </p>

      <pre class="screen screen_pre">
function name_1(parameters, name_2) {           // name_2 без скобок ()
    expression_1;
    name_2();                                   // скобки () только здесь
}

function name_2() {                             // Callback функция
    expression_2;
}</pre>
      <pre class="screen screen_pre">
function name_1(parameters, function() {        // анонимная Callback функция
    expression_1;
});</pre>
    </section>

    <section class="section">
      <h2 class="section__header">Стрелочные функции</h2>

      <pre class="screen screen_pre">
let name_1 = (parameters) =&gt; {
    expression_1;
};</pre>
      <p class="p">
        Не имеют <strong>this</strong> и <strong>arguments</strong>.
      </p>
      <pre class="screen screen_pre">
    Традиционная:

var name_1 = function(name_2) {
    expression_1;
}

    Стрелочная:

var name_1 = name_2 =&gt; expression_1;</pre>

      <p class="p">
        &bull;Стрелка <strong>=></strong> указывает на то, что должно быть возвращено, поэтому в данном примере можно не использовать <strong>return</strong>.<br>
        &bull;Если функция принимает только один аргумент (в данном примере это <strong>name_2</strong>), то можно убрать скобки обосабливающие аргументы
      </p>

      <pre class="screen screen_pre">
    Традиционная:

var name_1 = function(name_2, name_3) {
    return action_1;
}

    Стрелочная:

var name_1 = (name_2, name_3) =&gt; action_1</pre>

      <p class="p">
        Если тело функции состоит из нескольких строк, то его следует заключить в фигурные скобки.
      </p>
      <p class="p">
        Стрелочные функции не имеют контекста вызова <strong>this</strong>, и берут его у родителя.
      </p>
    </section>

    <section class="section">
      <h2 class="section__header">Самовызывающаяся функция</h2>

      <pre class="screen screen_pre">
(function name_1() {
    expression_1;
}());</pre>
      <p class="p">
        Анонимная самовызывающаяся функция.<br>
        Вызывается сразу после объявления.<br>
        Позволяет получить локальную область видимости.
      </p>
    </section>

    <section class="section">
      <h2 class="section__header">Функции как значения</h2>

      <p class="p">
        Функции в JavaScript являются значениями - значениями, которые могут присваиваться переменным.
      </p>
      <pre class="screen screen_pre">
function name_1(parameter_1) {
    action_1;
}

let name_2 = function(parameter_2) {
    action_2;
};

let name_3 = name_1;
let name_4 = name_2;

name_3(value_1);
name_4(value_2);</pre>
      <p class="p">
        &bull; Ссылка на функции содержащиеся в переменных <strong>name_1</strong> и <strong>name_2</strong> присваиваются переменным <strong>name_3</strong> и <strong>name_4</strong> соответственно.<br>
        &bull; Эти функции могут быть вызваны используя имена переменных <strong>name_3</strong> и <strong>name_4</strong> с круглыми скобками и атрибутами в них, если они есть.
      </p>
    </section>

    <section class="section">
      <h2 class="section__header">Передача аргументов в функцию</h2>

      <p class="p">
        &bull; При вызове функции ей передаются аргументы, которые сопоставляются с параметрами из определения функции. В аргументе можно передать практически любое значение. Переменные тоже могут передаваться как аргументы.<br>
        &bull; Параметры определяются один раз при определении функции (являются локальными переменными функции).<br>
        &bull; Аргументы передаются функции каждый раз при её вызове (значение аргумента копируется в параметр, или значение переменной копируется в параметр, являющийся переменной функции).
      </p>

      <pre class="screen screen_pre">
function name_1(parameter_1, parameter_2, ..., parameter_n) {
    action_1;
}

// или:

let name_1 = function(parameter_1, parameter_2, ..., parameter_n) {
    action_1;
};</pre>

      <p class="p"> 
        &bull; Параметрам не получившим аргумент присваивается значение <strong>undefined</strong>.<br>
        &bull; Если переданы лишние аргументы, то они игнорируются.
      </p>
    </section>

    <section class="section">
      <h2 class="section__header">Параметры по умолчанию</h2>

      <pre class="screen screen_pre">
function name_1(param_1=value_1, param_2=value_2 .... param_n=value_n) {
    action_1;
}</pre>
    </section>

    <section class="section">
      <h2 class="section__header">Возврат значения из функции</h2>

      <p class="p">
        &bull; Чтобы вернуть из функции значение, используется оператор <strong>return</strong>, после которого  указывается само значение.<br>
        &bull; После <strong>return</strong> все строки кода внутри функции игнорируются.<br>
        &bull; Оператор <strong>return</strong> включает выражение, которое возвращается в качестве результата вызова функции.
      </p>

      <pre class="screen screen_pre">
function name_1(parameter_1) {
    return action_1;
}

let name_1 = function(parameter_1) {
    return action_1;
}

let name_2 = name_1(parameter_1)</pre>
      <p class="p">
        Функция <strong>name_1</strong> возвращает значение переменной <strong>name_2</strong>.
      </p>

      <p class="p">
        Если не указать в теле функции, что именно возвращать, она вернёт <strong>undefined</strong>.
      </p>

      <div class="subsection">
        <h3 class="subsection__header">Ранний выход из функции по return</h3>

        <p class="p">
          &bull; Когда JavaScript, выполняя код функции, встречает оператор <strong>return</strong>, он завершает выполнение функции, даже если после остался код.<br>
          &bull; <strong>return</strong> часто используют для выхода из функции в самом начале, если какие-нибудь из переданных аргументов имеют некорректные значения - т.е. если с такими аргументами функция не сможет правильно работать.
        </p>
      </div>

      <div class="subsection">
        <h3 class="subsection__header">Многократное использование return вместо конструкций if ... else</h3>

        <pre class="screen screen_pre">
let name_1 = function (parameter_1) {
    if (condition_1) {
        return action_1;
    }

    if (condition_2) {
        return action_2;
    }

    return action_3;
};</pre>
      </div>
    </section>

    <section class="section">
      <h2 class="section__header">Замыкание</h2>

      <p class="p">
        - функция замыкает в своей области связанные с ней переменные внешней области.<br>
        - вновь создаваемая функция, содержащая свой переменный контекст.<br>
        - функция вместе с её окружением (свободными переменными), внутри лексической области действия (в теле функции, в которую они вложены).
      </p>

      <p class="p">
        Замыкания позволяют функциям работать, даже когда их среда существенно изменяется или исчезает. Любые переменные,
        находившиеся в области при создании функции, замыкаются и защищаются, чтобы обеспечить продолжение работы функции
      </p>

      <p class="p">
        <strong>замыкание = функция + внешний_контекст</strong>.<br>
        <strong>функция</strong> - обычно создаётся или возвращается другой функцией.<br>
        <strong>внешний_контекст</strong> - переменные, на которые опирается <strong>функция</strong>.
      </p>

      <div class="subsection">
        <h3 class="subsection__header">Свободные переменные</h3>

        <p class="p">
          - переменные используемые в теле вложенной функции и объявляемые за пределами этой вложенной функции, но при этом не являющиеся глобальными и находящиеся вместе с этой вложенной функцией внутри окружения лексической области действия в которой эта вложенная функция замкнута, и в этой же области содержатся значения этих переменных.
        </p>
        <p class="p">
          &bull; При выполнении замыкания в контексте, отличном от контекста его создания, значения свободных переменных определяются окружением.<br>
          &bull; Замыкания часто используются для сохра-нения состояния в обработчиках событий.
        </div>

      <div class="subsection">
        <h3 class="subsection__header">Замыкание при помощи возвращения функции</h3>

        <pre class="screen screen_pre">
let name_1 = x_1;
let name_2 = y_1;

function name_3() {
    let name_1 = x_2;
    let name_2 = y_2;

    return function () {
        return name_1 + name_2;
    }
}

let name_4 = name_3;

name_4(); // >> x_2 + y_2</pre>

        <pre class="screen screen_post">
Счётчик с замыканием:

function name_1() {
    let name_2 = 0;

    function name_3() {
        name_2 = name_2 + 1;
        return name_2;         
    }

    return name_3;
}

let name_4 = name_1;</pre>
        <p class="p">
          - счётчик с локальной и защищённой переменной <strong>name_2</strong>, которая не будет конфликтовать с другими переменными, а увеличить её можно только вызовом функции. Т.е. доступна она только через функцию.
        </p>

        <pre class="screen screen_post">
function name_1(name_2) {
    return function(name_3) {
        return name_3 + name_2;
    }
}

const name_4 = name_1(name_2);

console.log(name_4(name_3));</pre>
      </div>

      <p class="p">
        Замыкания создаются везде, где появляется ссылка на функцию со свободными переменными, и эта функция выполняется вне контекста, в котором она была создана.
      </p>

      <div class="subsection">
        <h3 class="subsection__header">Замыкание создаваемые передачей функции при вызове функции</h3>

        <p class="p">
          Передаваемая функция выполняется в контексте, отличном от контекста её создания.
        </p>

        <pre class="screen screen_post">
function name_1(string_1, x_1) {
    setTimeout( function() {
        alert(string_1);
    }, x_1);
}
                
name_1(string_1, x_1);
      </div>

      <p class="p">
        &bull; <strong>name_1</strong> - функциональное выражение содержащее свободную переменную <strong>string_1</strong>, передаётся параментру функции <strong>setTimeout</strong> в качестве значения аргумента.<br>
        &bull; При этом функциональное выражение обрабатывается для получения ссылки на функцию, которая затем передается <strong>setTimeout</strong>.<br>
        &bull; Метод <strong>setTimeout</strong> сохраняет функцию (а вернее, функцию вместе с окружением — иначе говоря, замыкание), после чего через <strong>x_1</strong> миллисекунд вызывает ее.
        &bull; Функция, передаваемая <strong>setTimeout</strong>, представляет собой замыкание, потому что вместе с ней передается окружение, связывающее свободную переменную <strong>string_1</strong> с значением передаваемым ей атрибутом.
      </p>
    </section>

    <section class="section">
      <h2 class="section__header">this</h2>

      <p class="p">
        - контекст вызова
      </p>

      <div class="subsection">
        <h3 class="subsection__header">В функции</h3>

        <pre class="screen screen_pre">
    // this. внутри функции:

function name_1() {
  this.... ;
}

    // this = window
    // (при 'use strict' this = undefined)</pre>
        <pre class="screen screen_pre">
    // this. внутри вложенной функции:

function name_1() {
  this.... ;
  function name_2() {
    this.... ;
  }
}
      
    // то же самое</pre>
      </div>

      <div class="subsection">
        <h3 class="subsection__header">В объекте</h3>

        <pre class="screen screen_pre">
    // Внутри метода объекта:

const name_1 = {
  name_11: value_11,
  name_12: value_12,
  name_13: function() {
    this.... ;
  }
}

    // this. = сам объект</pre>
        <pre class="screen screen_pre">
const name_1 = {
  name_11: value_11,
  name_12: value_12,
  name_13: function() {
    function() {
      this.... ;
    }
  }
}

    // this = window
    // (при 'use strict' this = undefined)</pre>
      </div>

      <div class="subsection">
        <h3 class="subsection__header">В Конструкторе и классе</h3>

        <pre class="screen screen_pre">
const Name_1(param_1, param_2, ...., param_n) {
  this.name_11 = param_1;
  this.name_12 = param_2;
  .... ;
  this.name_m1 = function() {
    expression with this;
  };
}

    // this = новый экземпляр объекта</pre>

      </div>

      <div class="subsection">
        <h3 class="subsection__header">Ручное присвоение контекста</h3>

        <div class="subsubsection">
          <h4 class="subsubsection__header">.call() и .apply()</h4>

          <pre class="screen screen_pre">
function name_1() {
  this.name_21 .... ;
}

const name_2 = {
  name_21: value_21
}

name_1.call(name_2);    // передаём функции name_1 контекст вызова name_2
name_1.apply(name_2);   // (в данном случае аналогично .call())

-------------------------------------------------------------------------

function name_1(param_1) {
  this.name_21 .... param_1;
}

const name_2 = {
  name_21: value_21
}

name_1.call(name_2, value_3);
name_1.apply(name_2, [value_3]);    // Передаёт аргументы в массиве</pre>
        </div>

        <div class="subsubsection">
          <h4 class="subsubsection__header">.bind()</h4>

          <p class="p">
            Создаёт новую функцию и под неё подвязывает контекст.
          </p>
          <pre class="screen screen_pre">
function name_1(param_1) {
  return this * param_1;
}

const name_2 = name_1.bind(context_1);

console.log(name_2(value_1));           //-> value_1 * param_1

    // Или:   ----------------------------

function name_1() {
  this.name_21 ....;
}

const name_2 = {
  name_21: value_21,
  name_22: value_22,
  ....
}

const name_3 = name_1.bind(name_2);</pre>

        <pre class="screen screen_post">
const btn = document.querySelector('.btn');

btn.addEventListener('click', function() {
  this.style.backgroundColor = 'red';
});

  // чаще пишут так: ---------------------

....
btn.addEventListener('click', (e) => {
  e.target.style.backgroundColor = 'red';
});</pre>
      </div>

      <div class="subsection">
        <h3 class="subsection__header">Внутри стрелочной функции</h3>

        <pre class="screen screen_pre">
const name_1 = {
  name_11: value_11,
  name_12: value_12,
  name_13: function() {
    const name_2 = () => {
      this.name_11 .... ;       // this.name_11 = value_11
    };
  }
}</pre>
        <p class="p">
          Стрелочная функция не имеет контекста вызова и берёт его у родителя.<br>
          Если нет у родителя,то равна либо <strong>undefined</strong>(при 'use strict') / либо <strong>window</strong>.
        </p>
      </div>
    </section>

    <section class="section">
      <h2 class="section__header">Функция-генератор</h2>

      <pre class="screen screen_pre">
function* name_1() {
  yield value_1;      //-> {value: value_1, done: false}
  yield value_2;
  yield value_3;
  yield value_4;
  yield value_5;      //-> {value: value_5, done: true}
}

let name_2 = name_1();          // ф-г "помещают внутрь" переменной

let name_3 = name_2.next();     // next() - метод ф-г</pre>
      <p class="p">
        <strong>done:</strong> - окончание "магазина" генератора.
      </p>

<pre class="screen screen_post">
function* name_1(n) {
  for (let i=0; i &lt; n; i++) {
    yield i;
  }
}

let counter = name_1(3);
console.log(counter.next().value);  //-> 0
console.log(counter.next().value);  //-> 1</pre>
    </section>
  </main>
</body>
</html>