<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Other</title>
    <link rel="stylesheet" href="../../styles/style.css">
</head>

<body class="body">
    <header class="header">
        <a class="header__button"  href="../javascript.html">&uArr;</a>
        <h1 class="header__title">Other</h1>
    </header>

    <main class="main">
        <section class="section">
            <h2 class="section__header">Обработчик события</h2>

            <p class="paragraph">
                &bull; Обработчик события - фрагмент кода, который должен выполниться при возникновении события<br>
                &bull; Чтобы обработчик вызывался при возникновении события, его необходимо сначала зарегистрировать
            </p>

            <div class="subsection">
                <h3 class="subsection__header">Сначала пишем функцию, обрабатывающую событие</h3>

                <pre class="screen screen_pre">
function name_1() {
    ...
}</pre>
            </div>

            <div class="subsection">
                <h3 class="subsection__header">Создаём связь между функцией и событием</h3>

                <pre class="screen screen_pre">
name_2.name_3 = name_1;</pre>
            </div>  
        </section>

        <section class="section">
            <h2 class="section__header">Диалоговое окно</h2>

            <div class="subsection">
                <h3 class="subsection__header">prompt()</h3>
                    
                <p class="paragraph"><strong>prompt()</strong> принимает данные типа <strong>string</strong></p>
                <pre class="screen screen_pre">
let name_1 = prompt("string_1");</pre>
                <pre class="screen screen_pre">
let name_1 = prompt("string_1", "placeholder_string_1");</pre>
                <p class="paragraph">
                    &bull; создаём переменную <strong>name</strong> и присваиваем ей значение, которое вернёт вызов <strong>prompt()</strong><br>
                    &bull; если нажать "Отмена", то <strong>prompt()</strong> вернёт <strong>null</strong>
                </p>
            </div>
                
            <div class="subsection">
                <h3 class="subsection__header">confirm()</h3>
                
                <p class="paragraph">Функция <strong>confirm</strong> позволяет задать вопрос, на который можно ответить <strong>"да"</strong> или <strong>"нет"</strong> и возвращает <strong>true</strong> или <strong>false</strong></p>
                <pre class="screen screen_post">
let ok = confirm("Жми OK!");

if (ok) {
    console.log("Молодцом!");
} else {
    console.log("Не на ту нажал!");
}</pre>
            </div>

            <div class="subsection">
                <h3 class="subsection__header">alert()</h3>

                <p class="paragraph">Отображается, пока пользователь не нажмёт <strong>OK</strong></p>
                <pre class="screen screen_post">
alert("А хорошо жить ещё лучше!");</pre>
            </div>
        </section>

        <section class="section">
            <h2 class="section__header">Вывод в консоль</h2>

            <pre class="screen screen_pre">
console.log('text');

consle.warn('text');

console.error('text');</pre>
        </section>

        <section class="section">
            <h2 class="section__header">Отложенное выполнение</h2>

            <p class="paragraph"><strong>setTimeout()</strong> и <strong>setInterval</strong> асинхронно вызывают функции</p>

            <div class="subsection">
                <h3 class="subsection__header">Через заданное время</h3>

                <p class="paragraph">Позволяет откладывать выполнение заданного кода</p>
                <pre class="screen screen_pre">
setTimeout(name_1, n);</pre>
                <p class="paragraph">
                    где:<br>
                    <strong>name_1</strong> - имя функции<br>
                    <strong>n</strong> - количество миллисекунд
                </p>
            </div>

            <div class="subsection">
                <h3 class="subsection__header">Через заданный интервал многократно</h3>

                <pre class="screen screen_pre">
setInterval(name_1, n);</pre>
                <p class="paragraph">
                    где:<br>
                    <strong>name_1</strong> - имя функции<br>
                    <strong>n</strong> - количество миллисекунд
                </p>
            </div>
        </section>

        <section class="section">
            <h2 class="section__header">Local Storage</h2>
           
            <p class="paragraph">Браузеры выделяют объём 10Мб</p>

            <div class="subsection">
                <h3 class="subsection__header">.getItem()</h3>

                <p class="paragraph">- метод для получения ключа из хранилища</p>
                <pre class="screen screen_pre">
localStorage.getItem(ключ);</pre>
            </div>

            <div class="subsection">
                <h3 class="subsection__header">.setItem()</h3>

                <p class="paragraph">- метод для создания новой записи в хранилище</p>
                
                <pre class="screen screen_pre">
 localStorage.setItem(ключ, значение);</pre>
               
                <pre class="screen screen_post">
 form.addEventListener("submit", function(evt) {
     if(!login.value || !password.value) {
         evt.preventDefault();
         console.log("Введите логин и пароль");
     } else {
         localStorage.setItem("login", login.value)
 });</pre>
 
                <p class="paragraph">Подстановка ранее сохранённого логина:</p>
                <pre class="screen screen_post">
 let popup = document.querySelector(".modal-login");
 let form = popup.query.Selector("form");
 let login = popup.querySelector("[name=login]");
 let password = popup.querySelector("name=password");
 let storage = localStorage.getItem("login");
 
 link.addEventListener("click", function(evt){
     evt.preventDefault();
     popup.classList.add("modal-show")
     if (storage) {
         login.value = storage;
         password.focus()
     } else {
         login.focus();
     }
 });</pre>
            </div>
 
            <div class="subsection">
                <h3 class="subsection__header">.removeItem()</h3>

                <p class="paragraph">- метод удаляет запись из хранилища</p>
            </div>
 
            <div class="subsection">
                <h3 class="subsection__header">clear()</h3>

                <p class="paragraph">- метод полной очистки хранилища</p>
            </div>
        </section>
 
        <section class="section">
            <h2 class="section__header">Canvas</h2>
    
            <div class="subsection">
                <h3 class="subsection__header">Context</h3>
    
                <div class="subsubsection">
                    <h4 class="subsubsection__header">Получение контекста</h4>
    
                    <pre class="screen screen_pre">
let canvas = document.getElementById('nameOfId')
let context = canvas.getContext('2d')</pre>
                    <p class="paragraph"><strong>nameOfId</strong> - имя идентификатора элемента в HTML (id="...")</p>
                </div>
            </div>
        </section>


        <section class="section">
            <h2 class="section__header">Аккордеон</h2>

            <pre class="screen screen_post">
    HTML:

&lt;div class="accordion"&gt;
    &lt;div class="accordion-item"&gt;
        &lt;div class="accordion-item__trigger"&gt;
            Trigger 1
        &lt;/div&gt;
        &lt;div class="accordion-item__content"&gt;
            Content 1
        &lt;/div&gt;
    &lt;/div&gt;
                    
    &lt;div class="accordion-item"&gt;
        &lt;div class="accordion-item__trigger"&gt;
            Trigger 2
        &lt;/div&gt;
        &lt;div class="accordion-item__content"&gt;
            Content 2
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
                    
                    
    CSS:
                    
.accordion {}
                    
.accordion-item {
    margin-bottom: 20px;
}

.accordion-item__trigger {}

.accordion-item__content {
    display: none;
}

.accordion-item--active .accordion-item__content {
    display: block;
}

    JavaScript:

document.querySelectorAll('.accordion-item__trigger').forEach((item) =>
    item.addEventListener('click', () => {
        const parent = item.parentNode;

        if (parent.classList.contains('accordion-item--active')) {
            parent.classList.remove('accordion-item--active')
        } else {
            document.querySelectorAll('.accordion-item').forEach((child) => child.classList.remove('accordion-item--active'))

            parent.classList.add('accordion-item--active');
        }
    });
)
                </pre>
            </div>

            <div class="subsection">
                <h3 class="subsection__header">Карусель</h3>

                <pre class="screen screen_post">
    HTML:


&lt;div class="slider-container"&gt;
    &lt;div class="slider-track"&gt;
        &lt;div class="slider-item"&gt;&lt;/div&gt;
        &lt;div class="slider-item"&gt;&lt;/div&gt;
            ...
        &lt;div class="slider-item"&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;div class="slider-buttons"&gt;
    &lt;div class="btn-prev"&gt;Preview&lt;/div&gt;
    &lt;div class="btn-next"&gt;Next&lt;/div&gt;
&lt;/div&gt;


    CSS:


.slider-container {
    overflow: hidden;
}
.slider-track {
    display: flex;
}
.slider-item {
    height: 100px;
}


    JavaScript:


let position = 0;

const slidesToShow = 3;
const slidesToScroll = 2;

const container = document.querySelector('.slider-container');
const track = document.querySelector('.slider-track');

const brnPrev = document.querySelector('.btn-prev');
const btnNext = document.querySelector('.btn-next');
const items = document.querySelectorAll('.slider-item');

const itemsCount = items.length;
const itemWidth = container.clientwidth / slidesToShow;
const movePosition = slidesToScroll * itemWidth;

item.forEach((item) =&gt; {
    item.style.minWidth = '${itemWidth}px';
});

btnNext.addEventListener('click', () =&gt; {
    const itemsLeft = itemsCount - (Math.abs(position) + slidesToShow * itemWidth) / itemWidth;

    position -= itemsLeft &gt;= slidesToScroll ? movePosition : itemsLeft * itemWidth;

    setPosition();
    checkBtns();
});

btnPrev.addEventListener('click', () =&gt; {
    const itemsLeft = Math.abs(position) / itemWidth;

    position += itemsLeft &gt;= slidesToScroll ? movePosition : itemsLeft * itemWidth;

    setPosition();
    checkBtns();
});

const setPosition = () =&gt; {
    track.style.transform = 'translateX(${position}px)';
};

const checkBtns = () =&gt; {
    btnPrev.disabled = position === 0;
    btnNext.disabled = position &lt;= -(itemsCount - slidesToShow) * itemWidth;
};

checkBtns(); </pre>
            </div>

            <div class="subsection">
                <h3 class="subsection__header">Затемняющаяся фиксированная шапка</h3>

                <pre class="screen screen_post">
(function() {
    const header = document.querySelector('.header');
    window.onscroll = () =&gt; {
        if (window.pageYOffset &gt; 1) {
            header.classList.add('header_active');
        } else {
            header.classList.remove('header_active');
        }
    };
}());</pre>
            </div>

            <div class="subsection">
                <h3 class="subsection__header">Выезжающее меню</h3>

                <pre class="screen screen_post">
(function() {
    const openMenu = document.querySelector('.burger');
    const menu = document.querySelector('.nav');
    const closeMenu = document.querySelector('.nav-close');
    openMenu.addEventListener('click', () => {
        menu.classList.add('nav_active');
    });
    closeMenu.addEventListener('click', () => {
        menu.classList.remove('nav_active');
    });
}());</pre>
            </div>
        </section>
    </main>
</body>
</html>