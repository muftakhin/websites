<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>ReactJS</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="../../../styles/style.css">
  <style>
    dl {
      width: 640px;
      margin: auto;
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: repeat(12, auto);
    }
    dt, dd {
      padding: 8px 16px;
      margin: 2px;
      font-size: 18px;
      border: 1px solid grey;
    }
    dt {
      background-color: #eee;
    }
  </style>
</head>

<body class="body">
  <header class="header">
    <a class="header__button"  href="../../other.html">&uArr;</a>
    <h1 class="header__title">События в React</h1>
  </header>

  <main class="main">
    <section class="section">
      <h2 class="section__header">Работа с событиями DOM в React</h2>

      <p class="p">
        Обработчик события (определение функции) определяется как значение атрибута элемента в JSX и как свойство элемента в простом коде JavaScript (когда createElement() вызывается напрямую без JSX)<br>
        Для атрибутов, которые являются именами событий, используются стандартные имена событийW3C DOM в верблюжьем регистре
      </p>

      <pre class="screen screen_pre">
onClick={function() {...}};

    // или

onClick={() => {...}};</pre>

      <p class="p">
        Можно определить слушателя события, который срабатывает, когда пользователь щелкает на кнопке. В слушателе события в консоль выводится контекст <strong>this</strong>. Объект события представляет собой расширенную версию объекта события DOM (с именем SyntheticEvent):
      </p>

      <pre class="screen screen_post">
&lt;button onClick={(function(event) {console.log(this, event)} ).bind(this)}&gt;
  Save
&lt;/button&gt;</pre>

      <p class="p">
        Вызов <strong>bind()</strong> необходим, чтобы в функции — обработчике события можно было получить ссылку на экземпляр класса (элемент React). Без вызова <strong>bind()</strong> она будет равна <strong>null</strong> (use strict mode).
      </p>
      <p class="p">
        Также можно добиться более элегантной записи, используя метод класса в качестве обработчика события (назовем его <strong>handleSave()</strong>) для события <strong>onClick</strong>:
      </p>
      <pre class="screen screen_post">
class SaveButton extends React.Component {
  handleSave(event) {
    console.log(this, event)
  }

  render() {
    return (
      &lt;button onClick={this.handleSave.bind(this)}&gt;   // Передаёт определение функции, возвращаемое bind(),
        Save                                          // событию onClick
      &lt;/button&gt;
    );
  }
}</pre>

      <p class="p">
        Обработчик события можно связать с классом в конструкторе класса. С функциональной точки зрения различий нет; но если вы используете тот же метод более одного раза в <strong>render()</strong>, связывание в конструкторе позволит устранить дублирование кода.
      </p>
      <pre class="screen screen_post">
class SaveButton extends React.Component {
  constructor(props) {
    super(props)
    this.handleSave = this.handleSave.bind(this)  // Связывает контекст this c классом, чтобы использовать this
  }                                               // в обработчике события для ссылок на этот класс

  handleSave(event) {
    console.log(this, event)
  }

  render() {
    return (
      &lt;button onClick={this.handleSave}&gt;         // Передает определение функции onClick
        Save
      &lt;/button&gt;
    );
  }
}</pre>
      <dl>
        <dt>События мыши</dt>
          <dd>
            onClick<br>
            onContextMenu<br>
            onDoubleClick<br>
            onDrag<br>
            onDragEnd<br>
            onDragEnter<br>
            onDragExit<br>
            onDragLeave<br>
            onDragOver<br>
            onDragStart<br>
            onDrop<br>
            onMouseDown<br>
            onMouseEnter<br>
            onMouseLeave<br>
            onMouseMove<br>
            onMouseOut<br>
            onMouseOver<br>
            onMouseUp
            </dd>
        <dt>События клавиатуры</dt>
          <dd>
            onKeyDown<br>
            onKeyPress<br>
            onKeyUp
          </dd>
        <dt>События буфера обмена</dt>
          <dd>
            onCopy<br>
            onCut<br>
            onPaste
          </dd>
        <dt>События форм</dt>
          <dd>
            onChange<br>
            onInput<br>
            onSubmit
          </dd>
        <dt>События фокуса</dt>
          <dd>
            onFocus<br>
            onBlur
          </dd>
        <dt>События касания</dt>
          <dd>
            onTouchCancel<br>
            onTouchEnd<br>
            onTouchMove<br>
            onTouchStart
          </dd>
        <dt>События UI</dt>
          <dd>
            onScroll
          </dd>
        <dt>События колеса</dt>
          <dd>
            onWheel
          </dd>
        <dt>События выделения</dt>
          <dd>
            onSelect
          </dd>
        <dt>События изображений</dt>
          <dd>
            onLoad<br>
            onError
          </dd>
        <dt>События анимации</dt>
          <dd>
            onAnimationStart<br>
            onAnimationEnd<br>
            onAnimationIteration
          </dd>
        <dt>События переходов</dt>
          <dd>
            onTransitionEnd
          </dd>
      </dl>

      <div class="subsection">
        <h3 class="subsection__header">Фазы спуска и подъёма</h3>

        <p class="p">
          Событие объявляется в JSX как атрибут (например, onClick={handleSave}). Если вы объявляете события мыши, имя атрибута может быть любым из поддерживаемых событий. Значением атрибута является обработчик события.
        </p>

        <pre class="screen screen_post">
&lt;div style={{border: '1px solid red'}} onMouseOver={()=>{console.log('mouse is over')}}&gt;
  Open DevTools and move your mouse cursor over here
&lt;/div&gt;</pre>
        <p class="p">
          Событие <strong>onMouseOver</strong>, инициируются событием в фазе подъема (<strong>bubble up</strong>). Также существует фаза спуска (<strong>trickle down</strong>/<strong>capture</strong>), предшествующая фазам подъема и цели. Сначала идет фаза спуска, от окна до целевого элемента, затем идет фаза цели, и только потом идет фаза подъема, когда событие перемещается вверх по дереву обратно к окну.
        </p>
        <p class="p">
          Различия между фазами особенно важны, когда одно событие используется для элемента и его предка(-ов). В режиме подъема событие сначала  перехватывается, затем обрабатывается внутренним элементом (целью), а затем распространяется во внешние элементы (предки, начиная с родителя цели). В режиме спуска событие сначала перехватывается внешним элементом, а затем распространяется на внутренние элементы.
        </p>
        <p class="p">
          Чтобы зарегистрировать слушателя события для фазы спуска, присоедините <strong>Capture</strong> к имени события. Например, вместо <strong>onMouseOver</strong> для обработки события mouseover в фазе спуска используется <strong>onMouseOverCapture</strong>. Это относится ко всем именам событий.
        </p>
      </div>
    </section>

    <section class="section">
      <h2 class="section__header">События React во внутренней реализации</h2>

      <p class="p">
        React не присоединяет слушателей событий к узлу DOM.<br>
        Событие не присоединяется ни к отдельному узлу (такому, как &lt;div&gt;), ни к элементу с атрибутом <strong>data-reactroot</strong>.<br>
        React присоединяет слушателя события к главному предку всех элементов — элементу <strong>document</strong>.
      </p>
    </section>

    <section class="section">
      <h2 class="section__header">Работа с объектами события React SyntheticEvent</h2>

      <p class="p">
        Во внутренней реализации React использует собственный класс для синтетических событий (<strong>SyntheticEvent</strong>).<br>
        Экземпляры класса <strong>SyntheticEvent</strong> передаются обработчику событий.<br>
        Чтобы получить доступ к объекту синтетического события, вы добавляете аргумент </strong>event</strong> функции-обработчику события.
      </p>
      <pre class="screen screen_post">
    // Получение синтетического события обработчиком:

class Mouse extends React.Component {
  render() {
    return (
      &lt;div&gt;
        &lt;div style={{border: '1px solid red'}} onMouseOver={((event)=&gt;{   // определяет аргумент event
          console.log('mouse is over with event')
          console.dir(event)                // Обращается к объекту SyntheticEvent для интерактивного вывода (dir)
        })} &gt;
          Open DevTools and move your mouse cursor over here
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}</pre>
      <p class="p">
        Код обработки события можно переместить в метод компонента или в отдельную функцию.<br>
        Как правило, в React обработчик события снабжается префиксом handle, чтобы отличить его от обычных методов класса, и именем события (например, mouseOver) или именем операции (например, save).
      </p>
      <pre class="screen screen_post">
    // Обработчик события как метод класса: связывание в render():

class Mouse extends React.Component {
  handleMouseOver(event) {
    console.log('mouse is over with event')
    console.dir(event.target)
  }

  render(){
    return (
      &lt;div&gt;
        &lt;div style={{border: '1px solid red'}} onMouseOver={this.handleMouseOver.bind(this)} &gt;
          Open DevTools and move your mouse cursor over here
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}</pre>

      <div class="table">
        <div class="table__header">Некоторые атрибуты и методы интерфейса SyntheticEvent:</div>
        <div class="table__screen">currentTarget</div>
        <div class="table__definition">DOMEventTarget элемента, перехватившего событие (может быть целью или родителем цели).</div>
        <div class="table__screen">target</div>
        <div class="table__definition">DOMEventTarget, то есть элемент, в котором было инициировано событие.</div>
        <div class="table__screen">nativeEvent</div>
        <div class="table__definition">DOMEvent, «родной» объект события браузера.</div>
        <div class="table__screen">preventDefault()</div>
        <div class="table__definition">блокирует поведение по умолчанию (например, ссылку или кнопку отправки данных формы).</div>
        <div class="table__screen">isDefaultPrevented()</div>
        <div class="table__definition">логическое значение: true, если поведение по умолчанию было заблокировано.</div>
        <div class="table__screen">stopPropagation()</div>
        <div class="table__definition">останавливает распространение события.</div>
        <div class="table__screen">isPropagationStopped()</div>
        <div class="table__definition">логическое значение: true, если распространение было заблокировано.</div>
        <div class="table__screen">type</div>
        <div class="table__definition">строковое имя.</div>
        <div class="table__screen">persist()</div>
        <div class="table__definition">удаляет синтетическое событие из пула и разрешает сохранение ссылок на событие в пользовательском коде.</div>
        <div class="table__screen">isPersistent</div>
        <div class="table__definition"> логическое значение: true, если объект SyntheticEvent был удален из пула.</div>
      </div>

      <p class="p">
        Синтетическое событие обнуляется (то есть становится недействительным) после того, как обработчик события завершит работу.
      </p>
    </section>

    <section class="section">
      <h2 class="section__header">Использование событий и состояния</h2>

      <pre class="screen screen_post">
class Content extends React.Component {
  constructor(props) {
    super(props);
    this.state = {counter: 0};      // Присваивает 0 счетчику в исходном состоянии
  }

  handleClick(event) {
    this.setState({counter: ++this.state.counter})    // Увеличивает значение счетчика на 1
  }

  render() {
    return (
      &lt;div&gt;
        &lt;button
        onClick={this.handleClick.bind(this)}    // Почему не this.handleClick() ??? *
        className="btn btn-primary"&gt;             // Присоединяет слушателя события onClick к триггеру handleClick
          Don't click me {this.state.counter} times!  // Выводит значение счетчика из состояния
        &lt;/button&gt;
      &lt;/div&gt;
    );
  }
}</pre>
      <p class="p">
        В <strong>constructor()</strong> значение <strong>this.state</strong> равно <strong>1</strong>, поэтому счётчику нужно присвоить <strong>0</strong> перед использованием его в представлении.<br>
        Метод <strong>handleClick()</strong> присваивает состоянию <strong>counter</strong> текущее значение <strong>counter</strong>, увеличенное на <strong>1</strong>.<br>
        * В значении атрибута <strong>onClick</strong>(в <strong>{....}</strong> ) функция не вызывается, а передаётся определение функции. При этом мы вызываем метод <strong>.bind()</strong>, чтобы использовать правильное значение <strong>this</strong>, т.к. <strong>.bind()</strong> возвращает определение функции.
      </p>
      <p class="p">
        Как и в случае с <strong>onClick</strong> или <strong>onMouseOver</strong>, вы можете использовать любые события DOM, поддерживаемые React.
      </p>
    </section>

    <section class="section">
      <h2 class="section__header">Передача обработчиков событий как свойств</h2>

      <p class="p">
        Инициирование события из компонента без состояния, заключается в передаче обработчика события как свойства этому компоненту без состояния и использования свойства (функции обработчика события) в компоненте без состояния (вызова функции).
      </p>
      <pre class="screen screen_post">
class ClickCounterButton extends React.Component {
  render() {
    return (
      &lt;button
      onClick={this.props.handler}
      className="btn btn-danger"&gt;
        Increase Volume (Current volume is {this.props.counter})
      &lt;/button&gt;
    );
  }
}</pre>
      <p class="p">
        Компонент <strong>ClickCounterButton</strong> не имеет собственного обработчика события <strong>onClick</strong> (то есть <strong>this.handler</strong> или <strong>this.handleClick</strong>).<br>
        Он использует обработчик, переданный ему родителем в свойстве <strong>this.props.handler</strong>.<br>
        Использование этого механизма полезно для обработки событий кнопки, потому что кнопка является компонентом без состояния. Эту кнопку можно
повторно использовать в других пользовательских интерфейсах.
      </p>
      <p class="p">
        Компонент <strong>ClickCounterButton</strong> также использует свойство <strong>counter</strong>, которое рендерится конструкцией <strong>{this.props.counter}</strong>.
      </p>
      <p class="p">
        Чтобы передать свойства <strong>counter</strong> и <strong>handler</strong> компоненту <strong>ClickCounterButton</strong>, укажите атрибуты в объявлении JSX параметра render родителя (в данном случае родителем является <strong>Content</strong>):
      </p>

      <pre class="screen screen_post">
class Content extends React.Component {
  constructor(props) {
    super(props);
    this.handleClick = this.handleClick.bind(this);
    this.state = {counter: 0};
  }

  handleClick(event) {
    this.setState({counter: ++this.state.counter})
  }

  render() {
    return (
      &lt;div&gt;
        &lt;ClickCounterButton
        counter={this.state.counter}
        handler={this.handleClick}/&gt;
      &lt;/div&gt;
    );
  }
}</pre>
      <p class="p">
       <strong>counter</strong> в <strong>ClickCounterButton</strong> является свойством, а следовательно, не может изменяться; но в родителе <strong>Content</strong> — это состояние, и оно может изменяться. Естественно, имена могут отличаться. Не обязательно использовать те же имена при передаче свойств дочерним элементам.
      </p>
      <p class="p">
        Исходное значение <strong>counter</strong> (состояние) задается равным нулю в родителе <strong>Content</strong>. Обработчик события также определяется в родителе. Таким образом, дочерний элемент (<strong>ClickCounterButton</strong>) инициирует событие на стороне родителя.
      </p>
    </section>

    <section class="section">
      <h2 class="section__header">Передача данных между компонентами</h2>

      <p class="p">
        Обработчик события можно разместить и в дочернем элементе, но использование родителя позволяет обмениваться информацией между дочерними компонентами.
      </p>
      <p class="p">
        На этот раз удалим значение счетчика из <strong>render()</strong><br>
        Компоненты представляют собой специализированные фрагменты представления, так что счетчик будет находиться в другом компоненте: <strong>Counter</strong>. А значит, всего в архитектуре будут задействованы три компонента: <strong>ClickCounterButton</strong>, <strong>Content</strong> и <strong>Counter</strong>
      </p>
      <p class="p">
        <strong>ClickCounterButton</strong> и <strong>Counter</strong> должны общаться друг с другом. Для этого они используют Content, а не передают данные напрямую (прямой обмен данными нежелателен, потому что он создает сильную связь).
      </p>

      <pre class="screen screen_post">
class ClickCounterButton extends React.Component {
  render() {
    return (
      &lt;button
      onClick={this.props.handler}
      className="btn btn-info"&gt;
        Don't touch me with your dirty hands!
      &lt;/button&gt;
    );
  }
}

// или:

const ClickCounterButton = (props) =&gt; {
  return (
    &lt;button
    onClick={props.handler}
    className="btn btn-info"&gt;
      Don't touch me with your dirty hands!
    &lt;/button&gt;
  );
}</pre>

      <p class="p">
        Следующий новый компонент <strong>Counter</strong> выводит свойство <strong>value</strong>, которое используется в качестве счетчика
      </p>
      <pre class="screen screen_post">
class Counter extends React.Component {
  render() {
    return (
      &lt;span&gt;
        Clicked {this.props.value} times.
      &lt;/span&gt;
    );
  }
}</pre>
      <p class="p">
        Родительского компонента, который предоставляет свойства: в одном передается обработчик события, а в другом счетчик
      </p>
      <pre class="screen screen_post">
class Content extends React.Component {
  constructor(props) {
    super(props);
    this.handleClick = this.handleClick.bind(this);
    this.state = {counter: 0};
  }

  handleClick(event) {
    this.setState({counter: ++this.state.counter})
  }

  render() {
    return (
      &lt;div&gt;
        &lt;ClickCounterButton handler={this.handleClick}/&gt;
        &lt;br/&gt;
        &lt;Counter value={this.state.counter}/&gt;
      &lt;/div&gt;
    );
  }
}</pre>
      <p class="p">
        Если нужно взаимодействие между дочерними компонентами, размещайте логику обработки событий в родителе или компоненте-обертке. Если событие относится только к дочерним компонентам, нет необходимости захламлять компоненты выше в иерархии методами обработки событий.
      </p>
    </section>

    <section class="section">
      <h2 class="section__header">Реакция на события DOM, не поддерживаемые React</h2>

      <pre class="screen screen_post">
class Radio extends React.Component {
  constructor(props) {
    super(props);
    this.handleResize = this.handleResize.bind(this);
    let order = props.order;
    let i=1;
    this.state = {                           // Сохраняет стили в состоянии
      outerStyle: this.getStyle(4, i),
      innerStyle: this.getStyle(1, i),
      selectedStyle: this.getStyle(2, i),
      taggerStyle: {top: order*20, width: 25, height: 25}
    }
  }

  getStyle(i, m) {            // Использует функцию для создания различных стилей из ширины
    let value = i * m;        // (которая позднее изменится) и множителя
    return (
      {
        top: value,
        bottom: value,
        left: value,
        right: value,
      }
    );
  }

  componentDidMount() {
    window.addEventListener('resize', this.handleResize)     // Присоединяет слушателя неподдерживаемого
  }                                                          // события к window

  componentWillUnmount() {
    window.removeEventListener('resize', this.handleResize)  // Удаляет слушателя неподдерживаемого
  }                                                          // события из window

  handleResize(event) {                                      // Реализует специальную функцию для масштабирования
    let w = 1 + Math.round(window.innerWidth / 300);         // переключателя на основании нового размера экрана
    this.setState({
      taggerStyle: {top: this.props.order*w*10, width: w*10, height: w*10},
      textStyle: {left: w*13, fontSize: 7*w}
    })
  } 

  render() {
    return (
      &lt;div&gt;
        &lt;div className="radio-tagger" style={this.state.taggerStyle}&gt;
          &lt;input type="radio" name={this.props.name} id={this.props.id}&gt;
          &lt;/input&gt;
          &lt;label htmlFor={this.props.id}&gt;
            &lt;div className="radio-text" style={this.state.textStyle}&gt;
              {this.props.label}
            &lt;/div&gt;
            &lt;div className="radio-outer" style={this.state.outerStyle}&gt;
              &lt;div className="radio-inner" style={this.state.innerStyle}&gt;
                &lt;div className="radio-selected" style={this.state.selectedStyle}&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/label&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}</pre>
      <p class="p">
        Слушатели события <strong>resize</strong> добавляются к window в <strong>componentDidMount()</strong>, а затем те же слушатели удаляются в <strong>componentWillUnmount()</strong>, чтобы после удаления компонента из DOM не оставалось ничего лишнего.
      </p>
      <p class="p">
        Вспомогательная функция <strong>getStyle()</strong> абстрагирует часть стилей, потому что в CSS встречаются повторения (top, bottom, left и right), но с разными значениями, зависящими от ширины окна. Соответственно, <strong>getStyle()</strong> получает значение и множитель m и возвращает значение в пикселах (числа в CSS-коде React интерпретируются как пикселы).
      </p>
    </section>

    <section class="section">
      <h2 class="section__header">Работа с формами</h2>

      <div class="subsection">
        <h3 class="subsection__header">Рекомендуемый способ работы с формами в React</h3>

        <pre class="screen screen_post">
      /* если вы реализуете поле &lt;input&gt; в HTML, React всегда будет синхронизировать render()
        с реальной моделью DOM.React не позволит пользователю изменить значение. */

render() {
  return (
    &lt;input type="text" name="title" value="Mr." /&gt;
  );
}

      // Сделаем значение поля ввода динамическим:

render() {
  return (
    &lt;input type="text" name="title" value={this.state.title} /&gt;
  );
}</pre>
        <pre class="screen screen_post">
      // Перехват изменений в onChange

handleChange(event) {
  this.setState({title: event.target.value})
}

render() {
  return (
    &lt;input type="text" name="title" value={this.state.title}
    onChange={this.handleChange.bind(this)}/&gt;
  );
}</pre>
        <p class="p">
          Лучше всего принять следующие меры для синхронизации внутреннего состояния с представлением:<br>
          1. Определить элементы в <strong>render()</strong> с использованием значений из <strong>state</strong>.<br>
          2. Сохранить изменение в элементе формы по мере их возникновения с использованием <strong>onChange</strong><br>
          3. Обновить внутреннее состояние в обработчике состояния<br>
          4. Новые значения сохраняются в <strong>state</strong>, после чего представление обновляется новым вызовом <strong>render()</strong>.
        </p>

        <p class="p">
          Такой подход называется односторонним связыванием, потому что состояние изменяет представления — и всё. В обратную сторону это не работает: только одностороннее движение от состояния к представлению. При одностороннем связывании библиотека не будет автоматически обновлять состояние (или модель). Одно из главных преимуществ одностороннего связывания заключается в том, что оно снижает сложность при работе с большими приложениями, в которых множественные представления могут неявно обновлять множественные состояния (модели данных) и наоборот.<br>
          И наоборот, двустороннее связывание позволяет представлениям автоматически изменять состояния без явной реализации процесса.  
        </p>

        <p class="p">
          Сначала рассмотрим рекомендованный способ работы с формами. Он называется использованием управляемых компонентов и гарантирует, что внутреннее состояние компонентов всегда синхронизировано с представлением.
        </p>

        <div class="subsubsection">
          <h4 class="subsubsection__header">Определение формы и ее событий в React</h4>

          <p class="p">
            Элемент <strong>&lt;form&gt;</strong> может обладать событиями:<br>
            1. <strong>onChange</strong> - инициализируется при изменении любых элементов ввода в форме.<br>
            2. <strong>onInput</strong> - инициализирууется при каждом изменении значений элементов <strong>textarea</strong> и <strong>input</strong> (не рекомендуется).<br>
            3. <strong>onSubmit</strong> - инициализируется при отправке формы.<br>
            а также </strong>onKeyUp</strong> и </strong>onClick</strong>.
          </p>
        </div>

        <div class="subsubsection">
          <h4 class="subsubsection__header">Определение элементов форм</h4>

          <p class="p">
            Почти все поля ввода в HTML реализуются всего четырьмя элементами: <strong>&lt;input&gt;</strong>, <strong>&lt;textarea&gt;</strong>, <strong>&lt;select&gt;</strong> и <strong>&lt;option&gt</strong>;<br>
            Чтобы придать этим элементам особый статус, в React они наделяются изменяемыми свойствами <strong>value</strong>, <strong>checked</strong> и <strong>selected</strong>. Эти специальные изменяемые свойства также называются интерактивными свойствами.<br>
            React DOM также поддерживает другие элементы, относящиеся к построению форм, такие как <strong>&lt;keygen&gt;</strong>, <strong>&lt;datalist&gt;</strong>, <strong>&lt;fieldset&gt;</strong> и <strong>&lt;label&gt;</strong>. Эти элементы не обладают такими суперспособностями, как изменяемый атрибут/свойство value, они рендерятся как соответствующие теги HTML
          </p>

          <p class="p">
            Интерактивные свойства/поля (те, что могут изменяться), которые могут читаться из таких событий, как onChange, присоединенных к элементам форм:<br>
            1. <strong>value</strong> - применяется к элементам <strong>&lt;input&gt;</strong>, <strong>&lt;textarea&gt;</strong> и <strong>&lt;select&gt;</strong>.<br>
            2. <strong>checked</strong> — применяется к элементам <strong>&lt;input&gt;</strong> с <strong>type="checkbox"</strong> и <strong>type="radio"</strong>.<br>
            3. <strong>selected</strong> — применяется к <strong>&lt;option&gt;</strong> (используется с <strong>&lt;select&gt;</strong>).<br>
            Можно читать их значения и изменять их, работая с этими интерактивными (изменяемыми) свойствами.
          </p>
        </div>

        <div class="subsubsection">
          <h4 class="subsubsection__header">Элемент &lt;INPUT&gt;</h4>

          <p class="p">
            Элемент <strong>&lt;input&gt;</strong> рендерит различные поля, используя разные значения для атрибута <strong>type</strong>:<br>
            - <strong>text</strong> — простое поле для ввода текста<br>
            - <strong>password</strong> - поле для ввода замаскированного текста (для сохранения конфиденциальности).<br>
            - <strong>radio</strong> - кнопка-переключатель. Используйте одинаковые имена для создания группы переключателей.<br>
            - <strong>checkbox</strong> - флажок. Используйте одинаковые имена для создания группы.<br>
            - <strong>button</strong> - элемент формы «кнопка».<br>
            Все эти элементы типа <strong>&lt;input&gt;</strong>, кроме флажков и переключателей, используются прежде всего для работы с value как интерактивным/изменяемым свойством элемента.
          </p>
          <pre class="screen screen_post">
      // для ввода адреса электронной почты может использовать
      // состояние email и обработчик события onChange:

&lt;input
type="text"
name="email"
value={this.state.email}
onChange={this.handleEmailChange}/&gt;</pre>
          <p class="p">
            Среди полей ввода есть два исключения, у которых <strong>value</strong> не является основным изменяемым атрибутом, — это типы <strong>checkbox</strong> и <strong>radio</strong>. Они используют значение <strong>checked</strong>, потому что эти два типа имеют одно значение на элемент HTML, а следовательно, значение не изменяется — но изменяется состояние <strong>checked/selected</strong>.
          </p>

          <pre class="screen screen_post">
class Content extends React.Component {
  constructor(props) {
    super(props);
    this.handleRadio = this.handleRadio.bind(this);
      ....
    this.state = {
      ....
      radioGroup: {
        angular: false,
        react: true,              // Назначает установленный переключатель по умолчанию в состоянии
        polymer: false
      }
    }
  }

   handleRadio(event) {
    let obj = {};                 // Стереть другие переключатели
    obj[event.target.value] = event.target.checked;  // true  //  Использует атрибут target.checked для получения
    this.setState({radioGroup: obj});                         // логического значения, показывающего,
  }                                                           // выбран ли данный переключатель.
  ....
  render() {
    return (
      &lt;form&gt;
        &lt;input type="radio"
        name="radioGroup"
        value='angular'                             // Жёстко фиксируется и изменять не надо.
        checked={this.state.radioGroup['angular']}  // Использует атрибут из объекта state или любого атрибута state.
        onChange={this.handleRadio}/&gt;               // Использует тот же обработчик события onChange, потому что
                                                    // значение переключателя можно получить из target.value.

        &lt;input type="radio"
        name="radioGroup"
        value='react'
        checked={this.state.radioGroup['react']}
        onChange={this.handleRadio}/&gt;

        &lt;input type="radio"
        name="radioGroup"
        value='polymer'
        checked={this.state.radioGroup['polymer']}
        onChange={this.handleRadio}/&gt;
        ....
      &lt;/form&gt;
    );
  }
}</pre>

          <p class="p">
            Для флажков применяется аналогичный подход: использование атрибута <strong>checked</strong> и логические значения для состояний. Эти логические значения  могут храниться в состоянии <strong>checkboxGroup</strong>:
          </p>
          <pre class="screen screen_post">
class Content extends React.Component {
  constructor(props) {
    super(props);
    this.handleCheckbox = this.handleCheckbox.bind(this);
    // ...
    this.state = {
    // ...
    checkboxGroup: {
      node: false,
      react: true,
      express: false,
      mongodb: false
    }
  }
}</pre>
          <p class="p">
            Затем обработчик события (который связывается в конструкторе) получает текущие значения, добавляет <strong>true</strong> или <strong>false</strong> из <strong>event.target.value</strong> и задает состояние:
          </p>
          <pre class="screen screen_post">
handleCheckbox(event) {
  let obj = Object.assign(this.state.checkboxGroup);
  obj[event.target.value] = event.target.checked;    // true или false;
  this.setState({checkboxGroup: obj});
}</pre>
          <p class="p">
            В присваивании из состояния в <strong>radio</strong> нет необходимости, потому что переключатели могут иметь только одно выбранное значение. А это означает, что вы можете использовать пустой объект. С флажками дело обстоит иначе: в группе может быть выбрано несколько значений, поэтому нужна операция слияния, а не замены.
          </p>
          <p class="p">
            В JavaScript объекты передаются и присваиваются по ссылке. Таким образом, в команде <strong>obj = this.state.checkboxGroup</strong> <strong>obj</strong> - в действительности является состоянием. Напомню, что состояние не должно изменяться напрямую. Для предотвращения любых потенциальных конфликтов лучше присваивать значение вызовом <strong>Object.assign()</strong>. Этот прием также называется клонированием.
          </p>
          <p class="p">
            Другой, менее эффективный и менее надежный способ присваивания основан на присваивании по значению с использованием JSON:
          </p>
          <pre class="screen screen_post">
clonedData = JSON.parse(JSON.stringify(originalData));</pre>
          <p class="p">
            Если используем массивы состояний вместо объектов и вам потребовалось выполнить присваивание по значению, используйте конструкцию <strong>clonedArray = Array.from(originArray)</strong> или <strong>clonedArray = originArray.slice()</strong>.<br>
            Обработчик события <strong>handleCheckbox()</strong> может использоваться для получения значения из <strong>event.target.value</strong>.
          </p>
          <pre class="screen screen_post">
&lt;input type="checkbox"
name="checkboxGroup"
value='node'
checked={this.state.checkboxGroup['node']}  // Использует состояние как значение. Это может быть атрибут объекта
onChange={this.handleCheckbox}/&gt;            // или просто атрибут state

&lt;input type="checkbox"
name="checkboxGroup"
value='react'
checked={this.state.checkboxGroup['react']}
onChange={this.handleCheckbox}/&gt;            // Использует onChange для отслеживания действий пользователя

&lt;input type="checkbox"
name="checkboxGroup"
value='express'
checked={this.state.checkboxGroup.express}  // Использует «точечную запись», когда ключи являются действительными
onChange={this.handleCheckbox}/&gt;            // именами JS

&lt;input type="checkbox"
name="checkboxGroup"
value='mongodb'
checked={this.state.checkboxGroup['mongodb']}
onChange={this.handleCheckbox}/&gt;              // Выполнять связывание в элементе не нужно, потому что оно
                                              // выполняется в конструкторе (истинно для всех флажков).</pre>
          <p class="p">
            При использовании флажков или переключателей можно жестко присвоить значение в каждом отдельном элементе и использовать <strong>checked</strong> как изменяемый атрибут.
          </p>
        </div>

        <div class="subsubsection">
          <h4 class="subsubsection__header">Элемент &lt;TEXTAREA&gt;</h4>

          <p class="p">
            Элементы <strong>&lt;textarea&gt;</strong> предназначены для получения и вывода длинных текстовых сообщений — заметок, сообщений в блогах, фрагментов кода и т. д.<br>
            В обычном HTML <strong>&lt;textarea&gt;</strong> использует внутреннюю разметку HTML (то есть дочерние элементы) в качестве значения.<br>
            React использует атрибут <strong>value</strong>.
          </p>
          <pre class="screen screen_post">
    // Не правильно:

&lt;textarea name="description"&gt;{this.state.description}&lt;/textarea&gt;


    // Правильно:

render() {
  return (
    &lt;textarea name="description" value={this.state.description}/&gt;
  );
}</pre>
          <p class="p">
            Чтобы прослушивать изменения, нужно использовать <strong>onChange</strong> как для элементов <strong>&lt;input&gt;</strong>.
          </p>
        </div>

        <div class="subsubsection">
          <h4 class="subsubsection__header">Элементы &lt;SELECT&gt; и &lt;OPTION&gt;</h4>

          <p class="p">
            Поля <strong>&lt;select&gt;</strong> и <strong>&lt;option&gt;</strong> очень удобны для выбора одного или нескольких значений из заранее заполненного списка значений.<br>
            В HTML для получения индекса выбранного элемента можно использовать <strong>selectDOMNode.selectedIndex</strong> или <strong>selectDOMNode.selectedOptions</strong>
          </p>
          <pre class="screen screen_post">
....
constructor(props) {
  super(props);
  this.state = {selectedValue: 'node'};
}

handleSelectChange(event) {
  this.setState({selectedValue: event.target.value});
}
....
render() {
  return (
    &lt;form&gt;
      &lt;select
      value={this.state.selectedValue}
      onChange={this.handleSelectChange}&gt;
        &lt;option value="ruby"&gt;Ruby&lt;/option&gt;
        &lt;option value="node"&gt;Node&lt;/option&gt;
        &lt;option value="python"&gt;Python&lt;/option&gt;
      &lt;/select&gt;
    &lt;/form&gt;
  }
....</pre>
          <p class="p">
          Этот фрагмент рендерит раскрывающееся меню и предварительно выбирает значение <strong>node</strong> (которое должно быть задано в конструкторе)<br>
          Иногда бывает нужно использовать элемент с множественным выделением. Это можно сделать в JSX/React, передавая атрибут <strong>multiple</strong> без значения (React по умолчанию использует <strong>true</strong>) или со значением <strong>{true}</strong>.
          </p>
          <p class="p">
          Чтобы осуществить предварительное выделение в списке нескольких элементов, можно передать <strong>&lt;select&gt;</strong> массив вариантов через атрибут </strong>value</strong>.
          </p>
          <pre class="screen screen_post">
&lt;select multiple={true} value={['meteor', 'react']}&gt;
  &lt;option value="meteor"&gt;Meteor&lt;/option&gt;
  &lt;option value="react"&gt;React&lt;/option&gt;
  &lt;option value="jQuery"&gt;jQuery&lt;/option&gt;
&lt;/select></pre>
          <p class="p">
            С <strong>multiple={true}</strong> генерируется элемент с множественным выделением, в котором предварительно выделены значения <strong>Meteor</strong> и <strong>React</strong>.
          </p>
        </div>

        <div class="subsubsrction">
          <h4 class="subsubsection__header">Отслеживание изменений в формах</h4>

          <p class="p">
            Чтобы отслеживать изменения в элементах форм, определяется слушатель события onChange. Это событие перекрывает нормальное событие DOM <strong>onInput</strong>.<br>
            Если понадобится обычное поведение <strong>onInput</strong> из HTML DOM, можно использовать событие <strong>onInput</strong> из React. С другой стороны, событие React <strong>onChange</strong> не полностью эквивалентно обычному событию DOM <strong>onChange</strong>. Обычное событие DOM <strong>onChange</strong> может инициироваться только при потере фокуса элементом, тогда как событие React <strong>onChange</strong> инициируется при любом новом вводе.
          </p>
          <p class="p">
            Условие срабатывания <strong>onChange</strong> зависит от конкретного элемента:<br>
            &bull; <strong>&lt;input&gt;</strong>, <strong>&lt;textarea&gt;</strong> и <strong>&lt;select&gt;</strong> — <strong>onChange</strong> инициируется изменением <strong>value</strong>.<br>
            &bull; <strong>&lt;input&gt;</strong> с  типом <strong>checkbox</strong> или <strong>radio</strong>  — <strong>onChange</strong> инициируется изменением <strong>checked</strong>.
          </p>
          <p class="p">
            Соответственно, изменяется и способ чтения значения. В аргументе обработчика события вы получаете объект <strong>SyntheticEvent</strong>. У него есть свойство <strong>target</strong> со значением <strong>value</strong>, <strong>checked</strong> или <strong>selected</strong> в зависимости от элемента.
          </p>
          <p class="p">
            Чтобы прослушивать изменения, вы определяете обработчик события где-то в своем компоненте (его также можно определить во встроенном формате, то есть в фигурных скобках JSX <strong>{}</strong>) и создать атрибут <strong>onChange</strong>, указывающий на обработчик события.
          </p>
          <pre class="screen screen_post">
    // Генерирование элементов форм и отслеживание изменений в поле для ввода адресов электронной почты:

handleChange(event) {
  console.log(event.target.value)
}

render() {
  return (
    &lt;input
    type="text"
    onChange={this.handleChange}
    defaultValue="ovna@code.ru"/&gt;
  );
}</pre>
          <p class="p">
            Интересно, что если вы не определите <strong>onChange</strong>, но предоставите <strong>value</strong>, React выдаст предупреждение и сделает элемент доступным только для чтения. Если вы намерены создать поле только для чтения, лучше определить его явно при помощи <strong>readOnly</strong>.<br>
            Чтобы явно задать значение, присвойте <strong>readOnly true</strong> (то есть <strong>readOnly={true}</strong>) или добавьте атрибут readOnly без значения; React по умолчанию добавит значение <strong>true</strong> к атрибуту.
          </p>
          <p class="p">
            Обнаруженные изменения в элементах можно сохранить в состоянии компонента:
          </p>
          <pre class="screen screen_post">
handleChange(event) {
  this.setState({emailValue: event.target.value})
}</pre>

          <p class="p">
            Создадим форму заявки на кредит с именем, адресом, номером телефона и номером социального страхования пользователя. Каждое поле обрабатывает свои изменения. В нижней части формы находится кнопка <strong>Submit</strong> для отправки состояния серверу. Ниже показано поле имени с <strong>onChange</strong>, которое сохраняет весь ввод в состоянии.
          </p>
          <pre class="screen screen_post">
constructor(props) {
  super(props);
  this.handleInput = this.handleInput.bind(this);
  this.handleSubmit = this.handleSubmit.bind(this);
  ....
}

handleFirstNameChange(event) {
  this.setState({firstName: event.target.value});  // Сохраняет изменения в поле firstName в состоянии
}
....
handleSubmit() {
  fetch(this.props['data-url'], {method: 'POST', body: JSON.stringify(this.state)})  // Отправляет данные по
  .then((response)=>{return response.json()})                                        // URL-адресу из свойства
  .then((data)=>{console.log('Submitted: ', data)});                                 // data-url с использованием
}                                                                       // браузерного Fetch API на базе обещаний

render() {
  return (
    &lt;form&gt;
      &lt;input name="firstName"
      onChange={this.handleFirstNameChange}
      type="text"/&gt;
      ....
      &lt;input
      type="button"
      onClick={this.handleSubmit}                             // Определяет обработчик события для кнопки Submit
      value="Submit"/&gt;
    &lt;/form&gt;
  );
}</pre>
        </div>

        <div class="subsubsection">
          <h4 class="subsubsection__header">Поле для банковского счета</h4>

          <pre class="screen screen_post">
class Content extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = {accountNumber: ''};                  // Задает пустую строку как исходный номер банковского счета
  }

  handleChange(event) {
    console.log('Typed: ', event.target.value);                     // Выводит нефильтрованное значение в том виде, в каком оно было введено
    this.setState({accountNumber: event.target.value.replace(/[^0-9]/ig,'')});  // Фильтрует значение и обновляет состояние
  }

  render() {
    return (
      &lt;div&gt;
        Account Number:
        &lt;input
        type="text"
        onChange={this.handleChange}              // Отслеживает изменения
        placeholder="123456"
        value={this.state.accountNumber}/&gt;     // Управляет элементом, присваивая значение state
        &lt;br/&gt;
        &lt;span&gt;{this.state.accountNumber.length&gt;0?'You entered: ' +   // Выводит номер счета, если он не пуст. «length» —
        this.state.accountNumber: ''}&lt;/span&gt;                            // строковое свойство, возвращающее количество
      &lt;/div&gt;                                                            // символов. Если значение пустое, ничего не выводится
    );
  }
}</pre>
          <p class="p">
            Для удаления всех с имволов, не являющихся цифрами, используется регулярное выражение <strong>/[^0-9]/ig</strong> и строковая функция <strong>replace</strong>. Конструкция <strong>replace(/[^0-9]/ig, '')</strong> — несложный вызов функции регулярных выражений, который заменяет все, кроме цифр, пустой строкой. Модификатор ig означает игнорирование регистра символов и глобальность (иначе говоря, ищутся все совпадения).
          </p>
          <p class="p">
            В <strong>render()</strong> присутствует поле ввода, которое является управляемым компонентом из-за <strong>value={this.state.accountNumber}</strong>. Если вы запустите этот пример, в поле будут вводиться только числовые данные, потому что React присваивает новому состоянию результат фильтрации введенных данных.
          </p>
        </div>
      </div>

      <div class="subsection">
        <h3 class="subsection__header">Альтернативные способы работы с формами</h3>

        <p class="p">
          Элементы форм могут быть неуправляемыми, если атрибуты <strong>value</strong> не заданы (ни в состоянии, ни в статическом значении). Неуправляемые элементы могут быть полезны при построении простой формы, которая будет отправлена серверу
        </p>
        <p class="p">
          Обычно для использования неуправляемых компонентов определяется событие отправки данных формы, как правило, это событие <strong>onClick</strong> для кнопки и/или <strong>onSubmit</strong> для формы.<br>
          При наличии такого обработчика возможны два варианта:<br>
          &bull; Отслеживать изменения так же, как при работе с управляемыми элементами, с использованием состояния для отправки, но не для значений.<br>
          &bull; Не отслеживать изменения.<br>
          Первый вариант достаточно прост: те же слушатели событий и обновление состояний. Получается слишком большой объем кода, если состояние используется только на последней стадии
        </p>

        <div class="subsubsection">
          <h4 class="subsubsection__header">Неуправляемые элементы с отслеживанием изменений</h4>

          <p class="p">
            Неуправляемый компонент означает, что свойство <strong>value</strong> не задается библиотекой React.<br>
            Когда это происходит, внутреннее значение (или состояние) компонента может отличаться от значения в представлении компонента. Фактически возникает диссонанс между внутренним состоянием и представлением. Состояние компонента может содержать логику (например, проверки данных); с паттерном неуправляемого компонента ваше представление будет получать весь пользовательский ввод в элементе формы, создавая расхождение между представлением и состоянием.
          </p>
          <pre class="screen screen_post">
    // Неуправляемое текстовое поле:

render() {
  return (
    &lt;input type="text" /&gt;
  );
}</pre>
          <p class="p">
            Любой пользовательский ввод будет немедленно рендериться в представлении.
          </p>
          <p class="p">
            Для отслеживания изменений в неуправляемом компоненте используется событие <strong>onChange</strong>
          </p>
          <p class="p">
            Метод <strong>handleChange()</strong>, который выводит значения в консоль и обновляет состояние с использованием <strong>event.target.value</strong>.
          </p>
          <pre class="screen screen_post">
class Content extends React.Component {
  constructor(props){
    super(props);
    this.state = {textbook: ''};  // Присваивает пустую строку в качестве исходного значения
  }

  handleChange(event) {
    console.log(event.target.value);
    this.setState({textbook: event.target.value});  // Обновляет состояние при каждом изменении в поле ввода
  }

  render() {
    return (
      &lt;div&gt;
        &lt;input
        type="text"
        onChange={this.handleChange}                // Не задает значение, только слушатель события
        placeholder="Eloquent TypeScript: Myth or Reality" /&gt;
        &lt;br/&gt;
        &lt;span&gt;{this.state.textbook}&lt;/span&gt;          // Использует &lt;span&gt; для вывода переменной состояния,
      &lt;/div&gt;                                        // значение которой будет задаваться в методе handleChange()
    );
  }
}</pre>
        </div>

        <div class="subsubsection">
          <h4 class="subsubsection__header">Использование ссылок для обращения к переменным</h4>

          <p class="p">
            При работе с неуправляемыми компонентами, не отслеживающими события (такие, как <strong>onChange</strong>), для обращения к значениям используются ссылки, однако ссылки не являются исключительной особенностью этого конкретного паттерна.
          </p>
          <p class="p">
            Ссылки позволяют вам получить элемент DOM (или узел) компонента React.js. Это может быть удобно, когда вам нужно получить значения элементов форм, но не отслеживать изменения в элементах.
          </p>
          <p class="p">
            Чтобы использовать ссылку, вы должны:<br>
            &bull; Убедиться в том, что у элемента в return метода render имеется атрибут с именем в верблюжьем регистре (например, <strong>email: &lt;input ref="userEmail" /&gt;</strong>).<br>
            &bull; Обратиться к  экземпляру DOM по именованной ссылке из другого метода. Например, в обработчике события <strong>this.refs.NAME</strong> превращается в <strong>this.refs.userEmail</strong>.
          </p>
          <p class="p">
            <strong>this.refs</strong>.NAME дает экземпляр компонента React.<br>
            Чтобы обратиться к узлу DOM компонента, вызовите <strong>ReactDOM.findDOMNode(this.refs.NAME)</strong>:
          </p>
          <pre class="screen screen_post">
let emailNode = ReactDOM.findDOMNode(this.refs.email);
let email = emailNode.value;

    // То же но с более удобным именем:

let fD = ReactDOM.findDOMNode;
let email = fD(this.refs.email).value;</pre>

          <p class="p">
            Когда нажата кнопка <strong>Submit</strong>,можно получить доступ к ссылкам <strong>emailAddress</strong> и <strong>comments</strong> и вывести значения на консоль:
          </p>
          <pre class="screen screen_post">
    // Начало формы с адресом электронной почты:

class Content extends React.Component {
  constructor(props) {
    super(props);
    this.submit = this.submit.bind(this);
    this.prompt = 'Please enter your email to win $1,000,000.';   // Определяет атрибут класса
  }

  submit(event) {
    let emailAddress = this.refs.emailAddress;
    let comments = this.refs.comments;
    console.log(ReactDOM.findDOMNode(emailAddress).value);  // Обращается к значению
    console.log(ReactDOM.findDOMNode(comments).value);      // адреса электронной почты по ссылке
  }

  render: function() {
    return (
      &lt;div className="well"&gt;
        &lt;p&gt;{this.prompt}&lt;/p&gt;
        &lt;div className="form-group"&gt;
          Email: &lt;input ref="emailAddress" className="form-control"
          type="text" placeholder="hi@azat.co"/&gt;
        &lt;/div&gt;
        &lt;div className="form-group"&gt;
          Comments: &lt;textarea ref="comments" className="form-control"
          placeholder="I like your website!"/&gt;
        &lt;/div&gt;
        &lt;div className="form-group"&gt;
          &lt;a className="btn btn-primary" value="Submit"
          onClick={this.submit}&gt;Submit&lt;/a&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}</pre>
          <p class="p">
            Обычный узел HTML DOM для <strong>&lt;textarea&gt;</strong> использует innerHTML в качестве значения. Как упоминалось ранее, в React для этого элемента можно использовать свойство <strong>value</strong>:
          </p>
          <pre class="screen screen_post">
ReactDOM.findDOMNode(comments).value;</pre>
          <p class="p">
            Поскольку метод <strong>ReactDOM.findDOMNode()</strong> возвращает узел DOM, вам доступны другие обычные атрибуты HTML (такие, как <strong>innerHTML</strong>) и методы (как <strong>getAttribute()</strong>).
          </p>
          <p class="p">
            Ссылки нужны только для тех редких случаев, когда используются неуправляемые элементы. Злоупотребление ссылками считается нежелательной практикой. В большинстве случаев не приходится использовать ссылки с управляемыми элементами, потому что вместо них можно использовать состояния компонентов.
          </p>
        </div>

        <div class="subsubsection">
          <h4 class="subsubsection__header">Значения по умолчанию</h4>

          <p class="p">
            В React специальный атрибут <strong>defaultValue</strong> задает значение и позволяет пользователям изменять элементы формы.
          </p>
          <p class="p">
            Если форма была сохранена ранее и необходимо заполнить поле <strong>&lt;input&gt;</strong> для удобства пользователя. В этом случае необходимо использовать свойство <strong>defaultValue</strong> для элементов формы. Исходное значение поля задается следующим образом:
          </p>
          <pre class="screen screen_post">
&lt;input type="text" name="new-book-title" defaultValue="Node: The Best Parts"/&gt;</pre>

          <p class="p">
            Если вместо defaultValue используется атрибут <strong>value (value="JSX")</strong>, этот элемент становится доступным только для чтения. Он не только будет управляемым, но и его значение не будет изменяться при вводе в элементе <strong>&lt;input&gt;</strong>. Дело в том, что значение жестко фиксировано, и React будет поддерживать это значение. В реальных приложениях значения получаются на программном уровне, что в React означает использование свойств (<strong>this.props.name</strong>):
          </p>
          <pre class="screen screen_post">
&lt;input type="text" name="new-book-title" defaultValue={this.props.title}/&gt;

    // Или состояний:

&lt;input type="text" name="new-book-title" defaultValue={this.state.title}/&gt;</pre>
          <p class="p">
            Атрибут React <strong>defaultValue</strong> чаще всего используется с неуправляемыми компонентами; но, как и в случае со ссылками, значения по умолчанию могут использоваться с управляемыми компонентами или в любых других сценариях. Правда, в управляемых компонентах значения по умолчанию уже не настолько актуальны, потому что эти значения можно определить в состоянии в конструкторе: например, <strong>this.state = { defaultName: 'Abe Lincoln'}</strong>.
          </p>
        </div>
      </div>
    </section>





    <section class="section">
      <h2 class="section__header">Прежний контент</h2>

      <div class="subsection">
        <h3 class="subsection__header">События SyntheticEvent</h3>

        <p class="paragraph">
          В React значение <strong>this</strong> не относится к элементу, который активировал событие<br>
          Нужно явно указывать связь с помощью метода <strong>.bind()</strong>
        </p>
        <pre class="screen screen_post">
  // счётчик кликов

class Counter extends React.Component {
  render() {
    var textStyle = {
      ...
    };
        
    return (
      &lt;div style={textStyle}&gt;
        {this.props.display}
      &lt;/div&gt;
    );
  }
}
        
class CounterParent extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      count: 0
    };

    this.increase = this.increase.bind(this);   // в этом примере this относится к CounterParent
  }
        
  increase(e) {                                 // События передают обработчику аргументы
    var currentCount = this.state.count;        // событий, назовём e

    if (e.shiftKey) {                           // shiftKey - свойство события SyntheticEvent
      currentCount += 10;                       // при использовании мыши
    } else {
      currentCount += 1;
    }

    this.setState(
      {count: currentCount}
    );
  }
        
  render() {
    var backgroundStyle = {
      ...
    };
        
    var buttonStyle = {
      ...
    };
        
    return (
      &lt;div style={backgroundStyle}&gt;
        &lt;Counter display={this.state.count} /&gt;
        &lt;button onClick={this.increase} style={buttonStyle}&gt;+&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}
        
ReactDOM.render(
  &lt;div&gt;
    &lt;CounterParent /&gt;
  &lt;/div&gt;,
  document.querySelector("#container")
);</pre>
        <p class="paragraph">
          &bull; Слушатель событий нельзя повесить на компонент, ибо компонент возвращает HTML-элемент<br>
          &bull; Нельзя напрямую прослушивать события компонета. Компонент это обёртка для элементов DOM<br>
          &bull; В React мы имеем дело с SyntheticEvent, а не обращаемся к событиям DOM<br>
          &bull; React никогда напрямую не прикрепляет обработчики событий к элементам DOM. Он использует один обработчик событий в корне документа, который отвечает за прослушку всех событий и при необходимости вызывает соответствующий обработчик событий
        </p>

        <p class="paragraph">
          Мы можем использовать обработчик событий как свойство и передать его компоненту. Внутри компонента мы можем затем назначить событие элементу DOM и присвоить обработчику события значение переданного свойства
        </p>
        <pre class="screen screen_post">
// вариант:

...
import PlusButton from './PlusButton';
...
render() {
  return(
    &lt;div&gt;
      &lt;Counter display={this.state.count} /&gt;
      &lt;PlusButton clickHandler={this.increase} /&gt;     // onClick повесить на PlusButton не получится
    &lt;/div&gt;
  );
}
...

// PlusButton.js

...
class PlusButton extends React.Component {
  render() {
    return(
      &lt;button onClick={this.props.clickHandler}&gt;
        +
      &lt;/button&gt;
    );
  }
}
...</pre>
        <p class="paragraph">
          &bull; В этом примере создаём свойство <strong>clickHandler</strong>, значение которого - обработчик события <strong>increase</strong><br>
          &bull; В элементе <strong>button</strong> указываем событие <strong>onClick</strong> и присваиваем его значение свойству <strong>clickHandler</strong><br>
          &bull; Во время выполнения свойство обрабатывается как функция <strong>increase</strong> , а нажатие кнопки «плюс» гарантирует вызов функции <strong>increase</strong>. Так наша проблема решается, позволяя компоненту участвовать во всем этом событии
        </p>
      </div>
      <div class="subsection">
        <h3 class="subsection__header">Стандартные события DOM</h3>

        <p class="paragraph">Не все события DOM имеют
          эквивалентные события SyntheticEvent</p>
        <pre class="screen screen_pre">
class Name_1 extends React.Component {                   // компонент Name_1 определяет событие event_1
  ...
  name_2(e) {
    action_2;
  }

  componentDidMount() {                                  // начинаем обрабатывать по методу componentDidMount(),
    window.addEventListener("event_1", this.name_2);     // который автоматически вызывается при визуализации
  }                                                      // компонента

  componentWillMount() {                                 // требуется удалить слушатель событий,
    window.removeEventListener("event_1", this.name_2);  // если компонент будет уничтожен
  }

  render() {
    ...
  }
}</pre>
      </div>
    </section>
  </main>
</body>