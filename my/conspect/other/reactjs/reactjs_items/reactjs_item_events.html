<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>ReactJS</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="../../../styles/style.css">
  <style>
    dl {
      width: 640px;
      margin: auto;
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: repeat(12, auto);
    }
    dt, dd {
      padding: 8px 16px;
      margin: 2px;
      font-size: 18px;
      border: 1px solid grey;
    }
    dt {
      background-color: #eee;
    }
  </style>
</head>

<body class="body">
  <header class="header">
    <a class="header__button"  href="../../other.html">&uArr;</a>
    <h1 class="header__title">События в React</h1>
  </header>

  <main class="main">
    <section class="section">
      <h2 class="section__header">Работа с событиями DOM в React</h2>

      <p class="p">
        Обработчик события (определение функции) определяется как значение атрибута элемента в JSX и как свойство элемента в простом коде JavaScript (когда createElement() вызывается напрямую без JSX)<br>
        Для атрибутов, которые являются именами событий, используются стандартные имена событийW3C DOM в верблюжьем регистре
      </p>

      <pre class="screen screen_pre">
onClick={function() {...}};

    // или

onClick={() => {...}};</pre>

      <p class="p">
        Можно определить слушателя события, который срабатывает, когда пользователь щелкает на кнопке. В слушателе события в консоль выводится контекст <strong>this</strong>. Объект события представляет собой расширенную версию объекта события DOM (с именем SyntheticEvent):
      </p>

      <pre class="screen screen_post">
&lt;button onClick={(function(event) {console.log(this, event)} ).bind(this)}&gt;
  Save
&lt;/button&gt;</pre>

      <p class="p">
        Вызов <strong>bind()</strong> необходим, чтобы в функции — обработчике события можно было получить ссылку на экземпляр класса (элемент React). Без вызова <strong>bind()</strong> она будет равна <strong>null</strong> (use strict mode).
      </p>
      <p class="p">
        Также можно добиться более элегантной записи, используя метод класса в качестве обработчика события (назовем его <strong>handleSave()</strong>) для события <strong>onClick</strong>:
      </p>
      <pre class="screen screen_post">
class SaveButton extends React.Component {
  handleSave(event) {
    console.log(this, event)
  }

  render() {
    return (
      &lt;button onClick={this.handleSave.bind(this)}&gt;   // Передаёт определение функции, возвращаемое bind(),
        Save                                          // событию onClick
      &lt;/button&gt;
    );
  }
}</pre>

      <p class="p">
        Обработчик события можно связать с классом в конструкторе класса. С функциональной точки зрения различий нет; но если вы используете тот же метод более одного раза в <strong>render()</strong>, связывание в конструкторе позволит устранить дублирование кода.
      </p>
      <pre class="screen screen_post">
class SaveButton extends React.Component {
  constructor(props) {
    super(props)
    this.handleSave = this.handleSave.bind(this)  // Связывает контекст this c классом, чтобы использовать this
  }                                               // в обработчике события для ссылок на этот класс

  handleSave(event) {
    console.log(this, event)
  }

  render() {
    return (
      &lt;button onClick={this.handleSave}&gt;         // Передает определение функции onClick
        Save
      &lt;/button&gt;
    );
  }
}</pre>
      <dl>
        <dt>События мыши</dt>
          <dd>
            onClick<br>
            onContextMenu<br>
            onDoubleClick<br>
            onDrag<br>
            onDragEnd<br>
            onDragEnter<br>
            onDragExit<br>
            onDragLeave<br>
            onDragOver<br>
            onDragStart<br>
            onDrop<br>
            onMouseDown<br>
            onMouseEnter<br>
            onMouseLeave<br>
            onMouseMove<br>
            onMouseOut<br>
            onMouseOver<br>
            onMouseUp
            </dd>
        <dt>События клавиатуры</dt>
          <dd>
            onKeyDown<br>
            onKeyPress<br>
            onKeyUp
          </dd>
        <dt>События буфера обмена</dt>
          <dd>
            onCopy<br>
            onCut<br>
            onPaste
          </dd>
        <dt>События форм</dt>
          <dd>
            onChange<br>
            onInput<br>
            onSubmit
          </dd>
        <dt>События фокуса</dt>
          <dd>
            onFocus<br>
            onBlur
          </dd>
        <dt>События касания</dt>
          <dd>
            onTouchCancel<br>
            onTouchEnd<br>
            onTouchMove<br>
            onTouchStart
          </dd>
        <dt>События UI</dt>
          <dd>
            onScroll
          </dd>
        <dt>События колеса</dt>
          <dd>
            onWheel
          </dd>
        <dt>События выделения</dt>
          <dd>
            onSelect
          </dd>
        <dt>События изображений</dt>
          <dd>
            onLoad<br>
            onError
          </dd>
        <dt>События анимации</dt>
          <dd>
            onAnimationStart<br>
            onAnimationEnd<br>
            onAnimationIteration
          </dd>
        <dt>События переходов</dt>
          <dd>
            onTransitionEnd
          </dd>
      </dl>

      <div class="subsection">
        <h3 class="subsection__header">Фазы спуска и подъёма</h3>

        <p class="p">
          Событие объявляется в JSX как атрибут (например, <strong>onClick={handleSave}</strong>). Если вы объявляете события мыши, имя атрибута может быть любым из поддерживаемых событий. Значением атрибута является обработчик события.
        </p>

        <pre class="screen screen_post">
&lt;div style={{border: '1px solid red'}} onMouseOver={()=>{console.log('mouse is over')}}&gt;
  Open DevTools and move your mouse cursor over here
&lt;/div&gt;</pre>
        <p class="p">
          Событие <strong>onMouseOver</strong>, инициируются событием в фазе подъема (<strong>bubble up</strong>). Также существует фаза спуска (<strong>trickle down</strong>/<strong>capture</strong>), предшествующая фазам подъема и цели. Сначала идет фаза спуска, от окна до целевого элемента, затем идет фаза цели, и только потом идет фаза подъема, когда событие перемещается вверх по дереву обратно к окну.
        </p>
        <p class="p">
          Различия между фазами особенно важны, когда одно событие используется для элемента и его предка(-ов). В режиме подъема событие сначала  перехватывается, затем обрабатывается внутренним элементом (целью), а затем распространяется во внешние элементы (предки, начиная с родителя цели). В режиме спуска событие сначала перехватывается внешним элементом, а затем распространяется на внутренние элементы.
        </p>
        <p class="p">
          Чтобы зарегистрировать слушателя события для фазы спуска, присоедините <strong>Capture</strong> к имени события. Например, вместо <strong>onMouseOver</strong> для обработки события mouseover в фазе спуска используется <strong>onMouseOverCapture</strong>. Это относится ко всем именам событий.
        </p>
      </div>
    </section>

    <section class="section">
      <h2 class="section__header">События React во внутренней реализации</h2>

      <p class="p">
        React не присоединяет слушателей событий к узлу DOM.<br>
        Событие не присоединяется ни к отдельному узлу (такому, как <strong>&lt;div&gt;</strong>), ни к элементу с атрибутом <strong>data-reactroot</strong>.<br>
        React присоединяет слушателя события к главному предку всех элементов — элементу <strong>document</strong>.
      </p>
    </section>

    <section class="section">
      <h2 class="section__header">Работа с объектами события React SyntheticEvent</h2>

      <p class="p">
        Во внутренней реализации React использует собственный класс для синтетических событий (<strong>SyntheticEvent</strong>).<br>
        Экземпляры класса <strong>SyntheticEvent</strong> передаются обработчику событий.<br>
        Чтобы получить доступ к объекту синтетического события, вы добавляете аргумент <strong>event</strong> функции-обработчику события.
      </p>
      <pre class="screen screen_post">
    // Получение синтетического события обработчиком:

class Mouse extends React.Component {
  render() {
    return (
      &lt;div&gt;
        &lt;div style={{border: '1px solid red'}} onMouseOver={((event)=&gt;{     // Определяет аргумент event
          console.log('mouse is over with event')
          console.dir(event)                                                // Обращается к объекту SyntheticEvent
        })} &gt;                                                               // для интерактивного вывода (dir)
          Open DevTools and move your mouse cursor over here
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}</pre>
      <p class="p">
        Код обработки события можно переместить в метод компонента или в отдельную функцию.<br>
        Как правило, в React обработчик события снабжается префиксом <strong>handle</strong>, чтобы отличить его от обычных методов класса, и именем события (например, <strong>mouseOver</strong>) или именем операции (например, <strong>save</strong>).
      </p>
      <pre class="screen screen_post">
    // Обработчик события как метод класса: связывание в render():

class Mouse extends React.Component {
  handleMouseOver(event) {
    console.log('mouse is over with event')
    console.dir(event.target)
  }

  render(){
    return (
      &lt;div&gt;
        &lt;div style={{border: '1px solid red'}} onMouseOver={this.handleMouseOver.bind(this)} &gt;
          Open DevTools and move your mouse cursor over here
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}</pre>

      <div class="table">
        <div class="table__header">Некоторые атрибуты и методы интерфейса SyntheticEvent:</div>
        <div class="table__screen">currentTarget</div>
        <div class="table__definition">DOMEventTarget элемента, перехватившего событие (может быть целью или родителем цели).</div>
        <div class="table__screen">target</div>
        <div class="table__definition">DOMEventTarget, то есть элемент, в котором было инициировано событие.</div>
        <div class="table__screen">nativeEvent</div>
        <div class="table__definition">DOMEvent, «родной» объект события браузера.</div>
        <div class="table__screen">preventDefault()</div>
        <div class="table__definition">блокирует поведение по умолчанию (например, ссылку или кнопку отправки данных формы).</div>
        <div class="table__screen">isDefaultPrevented()</div>
        <div class="table__definition">логическое значение: true, если поведение по умолчанию было заблокировано.</div>
        <div class="table__screen">stopPropagation()</div>
        <div class="table__definition">останавливает распространение события.</div>
        <div class="table__screen">isPropagationStopped()</div>
        <div class="table__definition">логическое значение: true, если распространение было заблокировано.</div>
        <div class="table__screen">type</div>
        <div class="table__definition">строковое имя.</div>
        <div class="table__screen">persist()</div>
        <div class="table__definition">удаляет синтетическое событие из пула и разрешает сохранение ссылок на событие в пользовательском коде.</div>
        <div class="table__screen">isPersistent</div>
        <div class="table__definition"> логическое значение: true, если объект SyntheticEvent был удален из пула.</div>
      </div>

      <p class="p">
        Синтетическое событие обнуляется (то есть становится недействительным) после того, как обработчик события завершит работу.
      </p>
    </section>

    <section class="section">
      <h2 class="section__header">Использование событий и состояния</h2>

      <pre class="screen screen_post">
class Content extends React.Component {
  constructor(props) {
    super(props);
    this.state = {counter: 0};      // Присваивает 0 счетчику в исходном состоянии
  }

  handleClick(event) {
    this.setState({counter: ++this.state.counter})    // Увеличивает значение счетчика на 1
  }

  render() {
    return (
      &lt;div&gt;
        &lt;button
        onClick={this.handleClick.bind(this)}    // Почему не this.handleClick() ??? *
        className="btn btn-primary"&gt;             // Присоединяет слушателя события onClick к триггеру handleClick
          Don't click me {this.state.counter} times!  // Выводит значение счетчика из состояния
        &lt;/button&gt;
      &lt;/div&gt;
    );
  }
}</pre>
      <p class="p">
        В <strong>constructor()</strong> значение <strong>this.state</strong> равно <strong>1</strong>, поэтому счётчику нужно присвоить <strong>0</strong> перед использованием его в представлении.<br>
        Метод <strong>handleClick()</strong> присваивает состоянию <strong>counter</strong> текущее значение <strong>counter</strong>, увеличенное на <strong>1</strong>.<br>
        * В значении атрибута <strong>onClick</strong>(в <strong>{....}</strong> ) функция не вызывается, а передаётся определение функции. При этом мы вызываем метод <strong>.bind()</strong>, чтобы использовать правильное значение <strong>this</strong>, т.к. <strong>.bind()</strong> возвращает определение функции.
      </p>
      <p class="p">
        Как и в случае с <strong>onClick</strong> или <strong>onMouseOver</strong>, вы можете использовать любые события DOM, поддерживаемые React.
      </p>
    </section>

    <section class="section">
      <h2 class="section__header">Передача обработчиков событий как свойств</h2>

      <p class="p">
        Инициирование события из компонента без состояния, заключается в передаче обработчика события как свойства этому компоненту без состояния и использования свойства (функции обработчика события) в компоненте без состояния (вызова функции).
      </p>
      <pre class="screen screen_post">
class ClickCounterButton extends React.Component {
  render() {
    return (
      &lt;button
      onClick={this.props.handler}
      className="btn btn-danger"&gt;
        Increase Volume (Current volume is {this.props.counter})
      &lt;/button&gt;
    );
  }
}</pre>
      <p class="p">
        Компонент <strong>ClickCounterButton</strong> не имеет собственного обработчика события <strong>onClick</strong> (то есть <strong>this.handler</strong> или <strong>this.handleClick</strong>).<br>
        Он использует обработчик, переданный ему родителем в свойстве <strong>this.props.handler</strong>.<br>
        Использование этого механизма полезно для обработки событий кнопки, потому что кнопка является компонентом без состояния. Эту кнопку можно
повторно использовать в других пользовательских интерфейсах.
      </p>
      <p class="p">
        Компонент <strong>ClickCounterButton</strong> также использует свойство <strong>counter</strong>, которое рендерится конструкцией <strong>{this.props.counter}</strong>.
      </p>
      <p class="p">
        Чтобы передать свойства <strong>counter</strong> и <strong>handler</strong> компоненту <strong>ClickCounterButton</strong>, укажите атрибуты в объявлении JSX параметра <strong>render</strong> родителя (в данном случае родителем является <strong>Content</strong>):
      </p>

      <pre class="screen screen_post">
class Content extends React.Component {
  constructor(props) {
    super(props);
    this.handleClick = this.handleClick.bind(this);
    this.state = {counter: 0};
  }

  handleClick(event) {
    this.setState({counter: ++this.state.counter})
  }

  render() {
    return (
      &lt;div&gt;
        &lt;ClickCounterButton
        counter={this.state.counter}
        handler={this.handleClick}/&gt;
      &lt;/div&gt;
    );
  }
}</pre>
      <p class="p">
       <strong>counter</strong> в <strong>ClickCounterButton</strong> является свойством, а следовательно, не может изменяться; но в родителе <strong>Content</strong> — это состояние, и оно может изменяться. Естественно, имена могут отличаться. Не обязательно использовать те же имена при передаче свойств дочерним элементам.
      </p>
      <p class="p">
        Исходное значение <strong>counter</strong> (состояние) задается равным нулю в родителе <strong>Content</strong>. Обработчик события также определяется в родителе. Таким образом, дочерний элемент (<strong>ClickCounterButton</strong>) инициирует событие на стороне родителя.
      </p>
    </section>

    <section class="section">
      <h2 class="section__header">Передача данных между компонентами</h2>

      <p class="p">
        Обработчик события можно разместить и в дочернем элементе, но использование родителя позволяет обмениваться информацией между дочерними компонентами.
      </p>
      <p class="p">
        На этот раз удалим значение счетчика из <strong>render()</strong><br>
        Компоненты представляют собой специализированные фрагменты представления, так что счетчик будет находиться в другом компоненте: <strong>Counter</strong>. А значит, всего в архитектуре будут задействованы три компонента: <strong>ClickCounterButton</strong>, <strong>Content</strong> и <strong>Counter</strong>
      </p>
      <p class="p">
        <strong>ClickCounterButton</strong> и <strong>Counter</strong> должны общаться друг с другом. Для этого они используют <strong>Content</strong>, а не передают данные напрямую (прямой обмен данными нежелателен, потому что он создает сильную связь).
      </p>

      <pre class="screen screen_post">
class ClickCounterButton extends React.Component {
  render() {
    return (
      &lt;button
      onClick={this.props.handler}
      className="btn btn-info"&gt;
        Don't touch me with your dirty hands!
      &lt;/button&gt;
    );
  }
}

// или:

const ClickCounterButton = (props) =&gt; {
  return (
    &lt;button
    onClick={props.handler}
    className="btn btn-info"&gt;
      Don't touch me with your dirty hands!
    &lt;/button&gt;
  );
}</pre>

      <p class="p">
        Следующий новый компонент <strong>Counter</strong> выводит свойство <strong>value</strong>, которое используется в качестве счетчика ...
      </p>
      <pre class="screen screen_post">
class Counter extends React.Component {
  render() {
    return (
      &lt;span&gt;
        Clicked {this.props.value} times.
      &lt;/span&gt;
    );
  }
}</pre>
      <p class="p">
        ... родительского компонента, который предоставляет свойства: в одном передается обработчик события, а в другом счетчик
      </p>
      <pre class="screen screen_post">
class Content extends React.Component {
  constructor(props) {
    super(props);
    this.handleClick = this.handleClick.bind(this);
    this.state = {counter: 0};
  }

  handleClick(event) {
    this.setState({counter: ++this.state.counter})
  }

  render() {
    return (
      &lt;div&gt;
        &lt;ClickCounterButton handler={this.handleClick}/&gt;
        &lt;br/&gt;
        &lt;Counter value={this.state.counter}/&gt;
      &lt;/div&gt;
    );
  }
}</pre>
      <p class="p">
        Если нужно взаимодействие между дочерними компонентами, размещайте логику обработки событий в родителе или компоненте-обертке. Если событие относится только к дочерним компонентам, нет необходимости захламлять компоненты выше в иерархии методами обработки событий.
      </p>
    </section>

    <section class="section">
      <h2 class="section__header">Реакция на события DOM, не поддерживаемые React</h2>

      <pre class="screen screen_post">
class Radio extends React.Component {
  constructor(props) {
    super(props);
    this.handleResize = this.handleResize.bind(this);
    let order = props.order;
    let i=1;
    this.state = {                           // Сохраняет стили в состоянии
      outerStyle: this.getStyle(4, i),
      innerStyle: this.getStyle(1, i),
      selectedStyle: this.getStyle(2, i),
      taggerStyle: {top: order*20, width: 25, height: 25}
    }
  }

  getStyle(i, m) {            // Использует функцию для создания различных стилей из ширины
    let value = i * m;        // (которая позднее изменится) и множителя
    return (
      {
        top: value,
        bottom: value,
        left: value,
        right: value,
      }
    );
  }

  componentDidMount() {
    window.addEventListener('resize', this.handleResize)     // Присоединяет слушателя неподдерживаемого
  }                                                          // события к window

  componentWillUnmount() {
    window.removeEventListener('resize', this.handleResize)  // Удаляет слушателя неподдерживаемого
  }                                                          // события из window

  handleResize(event) {                                      // Реализует специальную функцию для масштабирования
    let w = 1 + Math.round(window.innerWidth / 300);         // переключателя на основании нового размера экрана
    this.setState({
      taggerStyle: {top: this.props.order*w*10, width: w*10, height: w*10},
      textStyle: {left: w*13, fontSize: 7*w}
    })
  } 

  render() {
    return (
      &lt;div&gt;
        &lt;div className="radio-tagger" style={this.state.taggerStyle}&gt;
          &lt;input type="radio" name={this.props.name} id={this.props.id}&gt;
          &lt;/input&gt;
          &lt;label htmlFor={this.props.id}&gt;
            &lt;div className="radio-text" style={this.state.textStyle}&gt;
              {this.props.label}
            &lt;/div&gt;
            &lt;div className="radio-outer" style={this.state.outerStyle}&gt;
              &lt;div className="radio-inner" style={this.state.innerStyle}&gt;
                &lt;div className="radio-selected" style={this.state.selectedStyle}&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/label&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}</pre>
      <p class="p">
        Слушатели события <strong>resize</strong> добавляются к window в <strong>componentDidMount()</strong>, а затем те же слушатели удаляются в <strong>componentWillUnmount()</strong>, чтобы после удаления компонента из DOM не оставалось ничего лишнего.
      </p>
      <p class="p">
        Вспомогательная функция <strong>getStyle()</strong> абстрагирует часть стилей, потому что в CSS встречаются повторения (top, bottom, left и right), но с разными значениями, зависящими от ширины окна. Соответственно, <strong>getStyle()</strong> получает значение и множитель m и возвращает значение в пикселах (числа в CSS-коде React интерпретируются как пикселы).
      </p>
    </section>

    ---------------------------------------------------------------------------------------------------------------------------
    ---------------------------------------------------------------------------------------------------------------------------

    <section class="section">
      <h2 class="section__header">Прежний контент</h2>

      <div class="subsection">
        <h3 class="subsection__header">События SyntheticEvent</h3>

        <p class="paragraph">
          В React значение <strong>this</strong> не относится к элементу, который активировал событие<br>
          Нужно явно указывать связь с помощью метода <strong>.bind()</strong>
        </p>
        <pre class="screen screen_post">
  // счётчик кликов

class Counter extends React.Component {
  render() {
    var textStyle = {
      ...
    };
        
    return (
      &lt;div style={textStyle}&gt;
        {this.props.display}
      &lt;/div&gt;
    );
  }
}
        
class CounterParent extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      count: 0
    };

    this.increase = this.increase.bind(this);   // в этом примере this относится к CounterParent
  }
        
  increase(e) {                                 // События передают обработчику аргументы
    var currentCount = this.state.count;        // событий, назовём e

    if (e.shiftKey) {                           // shiftKey - свойство события SyntheticEvent
      currentCount += 10;                       // при использовании мыши
    } else {
      currentCount += 1;
    }

    this.setState(
      {count: currentCount}
    );
  }
        
  render() {
    var backgroundStyle = {
      ...
    };
        
    var buttonStyle = {
      ...
    };
        
    return (
      &lt;div style={backgroundStyle}&gt;
        &lt;Counter display={this.state.count} /&gt;
        &lt;button onClick={this.increase} style={buttonStyle}&gt;+&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}
        
ReactDOM.render(
  &lt;div&gt;
    &lt;CounterParent /&gt;
  &lt;/div&gt;,
  document.querySelector("#container")
);</pre>
        <p class="paragraph">
          &bull; Слушатель событий нельзя повесить на компонент, ибо компонент возвращает HTML-элемент<br>
          &bull; Нельзя напрямую прослушивать события компонета. Компонент это обёртка для элементов DOM<br>
          &bull; В React мы имеем дело с SyntheticEvent, а не обращаемся к событиям DOM<br>
          &bull; React никогда напрямую не прикрепляет обработчики событий к элементам DOM. Он использует один обработчик событий в корне документа, который отвечает за прослушку всех событий и при необходимости вызывает соответствующий обработчик событий
        </p>

        <p class="paragraph">
          Мы можем использовать обработчик событий как свойство и передать его компоненту. Внутри компонента мы можем затем назначить событие элементу DOM и присвоить обработчику события значение переданного свойства
        </p>
        <pre class="screen screen_post">
// вариант:

...
import PlusButton from './PlusButton';
...
render() {
  return(
    &lt;div&gt;
      &lt;Counter display={this.state.count} /&gt;
      &lt;PlusButton clickHandler={this.increase} /&gt;     // onClick повесить на PlusButton не получится
    &lt;/div&gt;
  );
}
...

// PlusButton.js

...
class PlusButton extends React.Component {
  render() {
    return(
      &lt;button onClick={this.props.clickHandler}&gt;
        +
      &lt;/button&gt;
    );
  }
}
...</pre>
        <p class="paragraph">
          &bull; В этом примере создаём свойство <strong>clickHandler</strong>, значение которого - обработчик события <strong>increase</strong><br>
          &bull; В элементе <strong>button</strong> указываем событие <strong>onClick</strong> и присваиваем его значение свойству <strong>clickHandler</strong><br>
          &bull; Во время выполнения свойство обрабатывается как функция <strong>increase</strong> , а нажатие кнопки «плюс» гарантирует вызов функции <strong>increase</strong>. Так наша проблема решается, позволяя компоненту участвовать во всем этом событии
        </p>
      </div>
      <div class="subsection">
        <h3 class="subsection__header">Стандартные события DOM</h3>

        <p class="paragraph">Не все события DOM имеют
          эквивалентные события SyntheticEvent</p>
        <pre class="screen screen_pre">
class Name_1 extends React.Component {                   // компонент Name_1 определяет событие event_1
  ...
  name_2(e) {
    action_2;
  }

  componentDidMount() {                                  // начинаем обрабатывать по методу componentDidMount(),
    window.addEventListener("event_1", this.name_2);     // который автоматически вызывается при визуализации
  }                                                      // компонента

  componentWillMount() {                                 // требуется удалить слушатель событий,
    window.removeEventListener("event_1", this.name_2);  // если компонент будет уничтожен
  }

  render() {
    ...
  }
}</pre>
      </div>
    </section>
  </main>
</body>